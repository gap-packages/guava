  
  [1X7 [33X[0;0YBounds on codes, special matrices and miscellaneous functions[133X[101X
  
  [33X[0;0YIn  this chapter we describe functions that determine bounds on the size and
  minimum  distance of codes (Section [14X7.1[114X), functions that determine bounds on
  the  size  and  covering  radius of codes (Section [14X7.2[114X), functions that work
  with  special  matrices [5XGUAVA[105X needs for several codes (see Section [14X7.3[114X), and
  constructing codes or performing calculations with codes (see Section [14X7.5[114X).[133X
  
  
  [1X7.1 [33X[0;0YDistance bounds on codes[133X[101X
  
  [33X[0;0YThis  section  describes  the  functions  that calculate estimates for upper
  bounds  on  the  size  and minimum distance of codes. Several algorithms are
  known to compute a largest number of words a code can have with given length
  and  minimum  distance.  It  is important however to understand that in some
  cases  the  true upper bound is unknown. A code which has a size equalto the
  calculated  upper  bound may not have been found. However, codes that have a
  larger size do not exist.[133X
  
  [33X[0;0YA  second  way  to obtain bounds is a table. In [5XGUAVA[105X, an extensive table is
  implemented for linear codes over [22XGF(2)[122X, [22XGF(3)[122X and [22XGF(4)[122X. It contains bounds
  on  the  minimum  distance  for given word length and dimension. It contains
  entries  for  word  lengths less than or equal to [22X257[122X, [22X243[122X and [22X256[122X for codes
  over  [22XGF(2)[122X,  [22XGF(3)[122X and [22XGF(4)[122X respectively. These entries were obtained from
  Brouwer's  tables  as of 11 May 2006. For the latest information, please see
  A. E. Brouwer's tables [Bro06] on the internet.[133X
  
  [33X[0;0YFirstly,  we  describe  functions  that compute specific upper bounds on the
  code  size  (see  [2XUpperBoundSingleton[102X  ([14X7.1-1[114X),  [2XUpperBoundHamming[102X  ([14X7.1-2[114X),
  [2XUpperBoundJohnson[102X   ([14X7.1-3[114X),   [2XUpperBoundPlotkin[102X   ([14X7.1-4[114X),  [2XUpperBoundElias[102X
  ([14X7.1-5[114X) and [2XUpperBoundGriesmer[102X ([14X7.1-6[114X)).[133X
  
  [33X[0;0YNext  we  describe  a function that computes [5XGUAVA[105X's best upper bound on the
  code size (see [2XUpperBound[102X ([14X7.1-8[114X)).[133X
  
  [33X[0;0YThen  we  describe two functions that compute a lower and upper bound on the
  minimum  distance  of  a  code  (see  [2XLowerBoundMinimumDistance[102X  ([14X7.1-9[114X) and
  [2XUpperBoundMinimumDistance[102X ([14X7.1-12[114X)).[133X
  
  [33X[0;0YFinally,  we describe a function that returns a lower and upper bound on the
  minimum  distance  with given parameters and a description of how the bounds
  were obtained (see [2XBoundsMinimumDistance[102X ([14X7.1-13[114X)).[133X
  
  [1X7.1-1 UpperBoundSingleton[101X
  
  [29X[2XUpperBoundSingleton[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0Y[10XUpperBoundSingleton[110X  returns  the  Singleton  bound  for a code of length [3Xn[103X,
  minimum  distance  [3Xd[103X  over  a  field  of  size [3Xq[103X. This bound is based on the
  shortening  of  codes.  By  shortening  an  [22X(n,  M,  d)[122X  code  [22Xd-1[122X times, an
  [22X(n-d+1,M,1)[122X code results, with [22XM â‰¤ q^n-d+1[122X (see [2XShortenedCode[102X ([14X6.1-9[114X)). Thus[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \leq q^{n-d+1}.[133X [124X[133X
  
  
  [33X[0;0YCodes  that  meet  this  bound  are  called  [13Xmaximum distance separable[113X (see
  [2XIsMDSCode[102X ([14X4.3-7[114X)).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XUpperBoundSingleton(4, 3, 5);[127X[104X
    [4X[28X25[128X[104X
    [4X[25Xgap>[125X [27XC := ReedSolomonCode(4,3);; Size(C);[127X[104X
    [4X[28X25[128X[104X
    [4X[25Xgap>[125X [27XIsMDSCode(C);[127X[104X
    [4X[28Xtrue [128X[104X
  [4X[32X[104X
  
  [1X7.1-2 UpperBoundHamming[101X
  
  [29X[2XUpperBoundHamming[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0YThe  Hamming bound (also known as the [13Xsphere packing bound[113X) returns an upper
  bound on the size of a code of length [3Xn[103X, minimum distance [3Xd[103X, over a field of
  size [3Xq[103X. The Hamming bound is obtained by dividing the contents of the entire
  space  [22XGF(q)^n[122X  by  the  contents  of a ball with radius [22XâŒŠ(d-1) / 2âŒ‹[122X. As all
  these  balls are disjoint, they can never contain more than the whole vector
  space.[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \leq {q^n \over V(n,e)},[133X [124X[133X
  
  
  [33X[0;0Ywhere  [22XM[122X  is  the  maxmimum  number  of codewords and [22XV(n,e)[122X is equal to the
  contents  of  a  ball of radius [22Xe[122X (see [2XSphereContent[102X ([14X7.5-5[114X)). This bound is
  useful  for  small  values  of  [3Xd[103X. Codes for which equality holds are called
  [13Xperfect[113X (see [2XIsPerfectCode[102X ([14X4.3-6[114X)).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XUpperBoundHamming( 15, 3, 2 );[127X[104X
    [4X[28X2048[128X[104X
    [4X[25Xgap>[125X [27XC := HammingCode( 4, GF(2) );[127X[104X
    [4X[28Xa linear [15,11,3]1 Hamming (4,2) code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize( C );[127X[104X
    [4X[28X2048 [128X[104X
  [4X[32X[104X
  
  [1X7.1-3 UpperBoundJohnson[101X
  
  [29X[2XUpperBoundJohnson[102X( [3Xn[103X, [3Xd[103X ) [32X function
  
  [33X[0;0YThe  Johnson  bound  is  an  improved  version  of  the  Hamming  bound (see
  [2XUpperBoundHamming[102X  ([14X7.1-2[114X)). In addition to the Hamming bound, it takes into
  account  the  elements of the space outside the balls of radius [22Xe[122X around the
  elements of the code. The Johnson bound only works for binary codes.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XUpperBoundJohnson( 13, 5 );[127X[104X
    [4X[28X77[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundHamming( 13, 5, 2);[127X[104X
    [4X[28X89   # in this case the Johnson bound is better [128X[104X
  [4X[32X[104X
  
  [1X7.1-4 UpperBoundPlotkin[101X
  
  [29X[2XUpperBoundPlotkin[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0YThe  function  [10XUpperBoundPlotkin[110X  calculates the sum of the distances of all
  ordered  pairs  of  different  codewords.  It  is based on the fact that the
  minimum  distance  is  at  most  equal to the average distance. It is a good
  bound if the weights of the codewords do not differ much. It results in:[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \leq {d \over {d-(1-1/q)n}},[133X [124X[133X
  
  
  [33X[0;0Ywhere  [22XM[122X  is the maximum number of codewords. In this case, [3Xd[103X must be larger
  than [22X(1-1/q)n[122X, but by shortening the code, the case [22Xd âŸ¨ (1-1/q)n[122X is covered.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XUpperBoundPlotkin( 15, 7, 2 );[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XC := BCHCode( 15, 7, GF(2) );[127X[104X
    [4X[28Xa cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize(C);[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XWeightDistribution(C);[127X[104X
    [4X[28X[ 1, 0, 0, 0, 0, 0, 0, 15, 15, 0, 0, 0, 0, 0, 0, 1 ] [128X[104X
  [4X[32X[104X
  
  [1X7.1-5 UpperBoundElias[101X
  
  [29X[2XUpperBoundElias[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0YThe   Elias   bound   is   an   improvement   of   the  Plotkin  bound  (see
  [2XUpperBoundPlotkin[102X  ([14X7.1-4[114X))  for  large codes. Subcodes are used to decrease
  the  size  of  the  code, in this case the subcode of all codewords within a
  certain  ball.  This  bound  is useful for large codes with relatively small
  minimum distances.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XUpperBoundPlotkin( 16, 3, 2 );[127X[104X
    [4X[28X12288[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundElias( 16, 3, 2 );[127X[104X
    [4X[28X10280 [128X[104X
    [4X[25Xgap>[125X [27XUpperBoundElias( 20, 10, 3 );[127X[104X
    [4X[28X16255[128X[104X
  [4X[32X[104X
  
  [1X7.1-6 UpperBoundGriesmer[101X
  
  [29X[2XUpperBoundGriesmer[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0YThe  Griesmer  bound  is  valid  only  for  linear  codes. It is obtained by
  counting  the number of equal symbols in each row of the generator matrix of
  the  code.  By  omitting  the  coordinates  in which all rows have a zero, a
  smaller  code  results.  The  Griesmer  bound  is obtained by repeating this
  proces until a trivial code is left in the end.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XUpperBoundGriesmer( 13, 5, 2 );[127X[104X
    [4X[28X64[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundGriesmer( 18, 9, 2 );[127X[104X
    [4X[28X8        # the maximum number of words for a linear code is 8[128X[104X
    [4X[25Xgap>[125X [27XSize( PuncturedCode( HadamardCode( 20, 1 ) ) );[127X[104X
    [4X[28X20       # this non-linear code has 20 elements [128X[104X
  [4X[32X[104X
  
  [1X7.1-7 IsGriesmerCode[101X
  
  [29X[2XIsGriesmerCode[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XIsGriesmerCode[110X  returns  `true'  if  a linear code [3XC[103X is a Griesmer code, and
  `false' otherwise. A code is called [13XGriesmer[113X if its length satisfies[133X
  
  
        [33X[1;6Y[24X[33X[0;0Yn = g[k,d] = \sum_{i=0}^{k-1} \lceil \frac{d}{q^i} \rceil.[133X [124X[133X
  
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XIsGriesmerCode( HammingCode( 3, GF(2) ) );[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XIsGriesmerCode( BCHCode( 17, 2, GF(2) ) );[127X[104X
    [4X[28Xfalse [128X[104X
  [4X[32X[104X
  
  [1X7.1-8 UpperBound[101X
  
  [29X[2XUpperBound[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0Y[10XUpperBound[110X  returns the best known upper bound [22XA(n,d)[122X for the size of a code
  of  length  [3Xn[103X,  minimum  distance  [3Xd[103X  over  a  field of size [3Xq[103X. The function
  [10XUpperBound[110X  first  checks  for  trivial  cases (like [22Xd=1[122X or [22Xn=d[122X), and if the
  value  is in the built-in table. Then it calculates the minimum value of the
  upper   bound  using  the  methods  of  Singleton  (see  [2XUpperBoundSingleton[102X
  ([14X7.1-1[114X)),    Hamming   (see   [2XUpperBoundHamming[102X   ([14X7.1-2[114X)),   Johnson   (see
  [2XUpperBoundJohnson[102X  ([14X7.1-3[114X)),  Plotkin  (see  [2XUpperBoundPlotkin[102X  ([14X7.1-4[114X)) and
  Elias  (see  [2XUpperBoundElias[102X ([14X7.1-5[114X)). If the code is binary, [22XA(n, 2â‹… â„“-1) =
  A(n+1,2â‹… â„“)[122X, so the [10XUpperBound[110X takes the minimum of the values obtained from
  all methods for the parameters [22X(n, 2â‹…â„“-1)[122X and [22X(n+1, 2â‹… â„“)[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XUpperBound( 10, 3, 2 );[127X[104X
    [4X[28X85[128X[104X
    [4X[25Xgap>[125X [27XUpperBound( 25, 9, 8 );[127X[104X
    [4X[28X1211778792827540 [128X[104X
  [4X[32X[104X
  
  [1X7.1-9 LowerBoundMinimumDistance[101X
  
  [29X[2XLowerBoundMinimumDistance[102X( [3XC[103X ) [32X function
  
  [33X[0;0YIn  this  form,  [10XLowerBoundMinimumDistance[110X  returns  a  lower  bound for the
  minimum distance of code [3XC[103X.[133X
  
  [33X[0;0YThis  command can also be called using the syntax [10XLowerBoundMinimumDistance(
  n, k, F )[110X. In this form, [10XLowerBoundMinimumDistance[110X returns a lower bound for
  the  minimum distance of the best known linear code of length [3Xn[103X, dimension [3Xk[103X
  over field [3XF[103X. It uses the mechanism explained in section [14X7.1-13[114X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC := BCHCode( 45, 7 );[127X[104X
    [4X[28Xa cyclic [45,23,7..9]6..16 BCH code, delta=7, b=1 over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundMinimumDistance( C );[127X[104X
    [4X[28X7     # designed distance is lower bound for minimum distance [128X[104X
    [4X[25Xgap>[125X [27XLowerBoundMinimumDistance( 45, 23, GF(2) );[127X[104X
    [4X[28X10 [128X[104X
  [4X[32X[104X
  
  [1X7.1-10 LowerBoundGilbertVarshamov[101X
  
  [29X[2XLowerBoundGilbertVarshamov[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0YThis  is the lower bound on the size of a linear code due (independently) to
  Gilbert  and Varshamov. It says that for each [3Xn[103X and [3Xd[103X, there exists a linear
  code having length [22Xn[122X and minimum distance [22Xd[122X at least of size [22Xq^k[122X, where [22Xk[122X is
  the largest integer such that [22Xq^k < q^n/[122X[10XSphereContent[110X[22X(n-1,d-2,GF(q))[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLowerBoundGilbertVarshamov(24,8,2);[127X[104X
    [4X[28X64[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundGilbertVarshamov(7,3,2);[127X[104X
    [4X[28X16[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundMinimumDistance(7,4,2);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundGilbertVarshamov(3,3,2);[127X[104X
    [4X[28X1[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundMinimumDistance(3,3,2);[127X[104X
    [4X[28X1[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundGilbertVarshamov(25,10,2);[127X[104X
    [4X[28X16[128X[104X
  [4X[32X[104X
  
  [1X7.1-11 LowerBoundSpherePacking[101X
  
  [29X[2XLowerBoundSpherePacking[102X( [3Xn[103X, [3Xd[103X, [3Xq[103X ) [32X function
  
  [33X[0;0YThis  is  the  (weaker) Gilbert-Varshamov bound valid for unrestricted codes
  over  an  alphabet  of  size [3Xq[103X (where [3Xq[103X is an integer > 1). It says that for
  each  [3Xn[103X  and  [3Xr[103X,  there  exists  an  unrestricted  code  at  least  of  size
  [22Xq^n/[122X[10XSphereContent[110X[22X(n,d,GF(q))[122X minimum distance [22Xd[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XLowerBoundSpherePacking(3,2,2);[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundSpherePacking(3,3,2);[127X[104X
    [4X[28X1[128X[104X
  [4X[32X[104X
  
  [1X7.1-12 UpperBoundMinimumDistance[101X
  
  [29X[2XUpperBoundMinimumDistance[102X( [3XC[103X ) [32X function
  
  [33X[0;0YIn  this  form,  [10XUpperBoundMinimumDistance[110X  returns  an  upper bound for the
  minimum distance of code [3XC[103X. For unrestricted codes, it just returns the word
  length.  For  linear codes, it takes the minimum of the possibly known value
  from the method of construction, the weight of the generators, and the value
  from the table (see [14X7.1-13[114X).[133X
  
  [33X[0;0YThis  command can also be called using the syntax [10XUpperBoundMinimumDistance(
  n,  k,  F  )[110X. In this form, [10XUpperBoundMinimumDistance[110X returns an upper bound
  for  the  minimum  distance  of  the  best  known  linear  code of length [3Xn[103X,
  dimension [3Xk[103X over field [3XF[103X. It uses the mechanism explained in section [14X7.1-13[114X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC := BCHCode( 45, 7 );;[127X[104X
    [4X[25Xgap>[125X [27XUpperBoundMinimumDistance( C );[127X[104X
    [4X[28X9 [128X[104X
    [4X[25Xgap>[125X [27XUpperBoundMinimumDistance( 45, 23, GF(2) );[127X[104X
    [4X[28X11 [128X[104X
  [4X[32X[104X
  
  [1X7.1-13 BoundsMinimumDistance[101X
  
  [29X[2XBoundsMinimumDistance[102X( [3Xn[103X, [3Xk[103X, [3XF[103X ) [32X function
  
  [33X[0;0YThe  function  [10XBoundsMinimumDistance[110X  calculates a lower and upper bound for
  the minimum distance of an optimal linear code with word length [3Xn[103X, dimension
  [3Xk[103X  over  field  [3XF[103X.  The function returns a record with the two bounds and an
  explanation  for  each  bound.  The function [10XDisplay[110X can be used to show the
  explanations.[133X
  
  [33X[0;0YThe  values  for  the lower and upper bound are obtained from a table. [5XGUAVA[105X
  has tables containing lower and upper bounds for [22Xq=2 (n â‰¤ 257), 3 (n â‰¤ 243),
  4 (n â‰¤ 256)[122X. (Current as of 11 May 2006.) These tables were derived from the
  table  of  Brouwer. (See [Bro06], [7Xhttp://www.win.tue.nl/~aeb/voorlincod.html[107X
  for  the  most recent data.) For codes over other fields and for larger word
  lengths, trivial bounds are used.[133X
  
  [33X[0;0YThe  resulting  record  can be used in the function [10XBestKnownLinearCode[110X (see
  [2XBestKnownLinearCode[102X  ([14X5.2-14[114X))  to  construct  a  code with minimum distance
  equal to the lower bound.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xbounds := BoundsMinimumDistance( 7, 3 );; DisplayBoundsInfo( bounds );[127X[104X
    [4X[28Xan optimal linear [7,3,d] code over GF(2) has d=4[128X[104X
    [4X[28X------------------------------------------------------------------------------[128X[104X
    [4X[28XLb(7,3)=4, by shortening of:[128X[104X
    [4X[28XLb(8,4)=4, u u+v construction of C1 and C2:[128X[104X
    [4X[28XLb(4,3)=2, dual of the repetition code[128X[104X
    [4X[28XLb(4,1)=4, repetition code[128X[104X
    [4X[28X------------------------------------------------------------------------------[128X[104X
    [4X[28XUb(7,3)=4, Griesmer bound[128X[104X
    [4X[28X# The lower bound is equal to the upper bound, so a code with[128X[104X
    [4X[28X# these parameters is optimal.[128X[104X
    [4X[25Xgap>[125X [27XC := BestKnownLinearCode( bounds );; Display( C );[127X[104X
    [4X[28Xa linear [7,3,4]2..3 shortened code of[128X[104X
    [4X[28Xa linear [8,4,4]2 U U+V construction code of[128X[104X
    [4X[28XU: a cyclic [4,3,2]1 dual code of[128X[104X
    [4X[28X   a cyclic [4,1,4]2 repetition code over GF(2)[128X[104X
    [4X[28XV: a cyclic [4,1,4]2 repetition code over GF(2)[128X[104X
  [4X[32X[104X
  
  
  [1X7.2 [33X[0;0YCovering radius bounds on codes[133X[101X
  
  [1X7.2-1 BoundsCoveringRadius[101X
  
  [29X[2XBoundsCoveringRadius[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XBoundsCoveringRadius[110X  returns  a  list  of integers. The first entry of this
  list  is  the maximum of some lower bounds for the covering radius of [3XC[103X, the
  last entry the minimum of some upper bounds of [3XC[103X.[133X
  
  [33X[0;0YIf  the  covering  radius  of  [3XC[103X  is  known, a list of length 1 is returned.
  [10XBoundsCoveringRadius[110X       makes       use       of       the      functions
  [10XGeneralLowerBoundCoveringRadius[110X and [10XGeneralUpperBoundCoveringRadius[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XBoundsCoveringRadius( BCHCode( 17, 3, GF(2) ) );[127X[104X
    [4X[28X[ 3 .. 4 ][128X[104X
    [4X[25Xgap>[125X [27XBoundsCoveringRadius( HammingCode( 5, GF(2) ) );[127X[104X
    [4X[28X[ 1 ] [128X[104X
  [4X[32X[104X
  
  [1X7.2-2 IncreaseCoveringRadiusLowerBound[101X
  
  [29X[2XIncreaseCoveringRadiusLowerBound[102X( [3XC[103X[, [3Xstopdist[103X][, [3Xstartword[103X] ) [32X function
  
  [33X[0;0Y[10XIncreaseCoveringRadiusLowerBound[110X  tries  to  increase the lower bound of the
  covering  radius  of  [3XC[103X. It does this by means of a probabilistic algorithm.
  This  algorithm  takes  a  random  word  in  [22XGF(q)^n[122X  (or [3Xstartword[103X if it is
  specified),  and, by changing random coordinates, tries to get as far from [3XC[103X
  as  possible.  If  changing  a  coordinate  finds  a  word that has a larger
  distance  to  the  code than the previous one, the change is made permanent,
  and  the  algorithm starts all over again. If changing a coordinate does not
  find  a  coset leader that is further away from the code, then the change is
  made  permanent with a chance of 1 in 100, if it gets the word closer to the
  code,  or  with a chance of 1 in 10, if the word stays at the same distance.
  Otherwise, the algorithm starts again with the same word as before.[133X
  
  [33X[0;0YIf  the  algorithm  did  not allow changes that decrease the distance to the
  code,  it  might  get  stuck  in  a  sub-optimal situation (the coset leader
  corresponding  to such a situation - i.e. no coordinate of this coset leader
  can  be changed in such a way that we get at a larger distance from the code
  - is called an [13Xorphan[113X).[133X
  
  [33X[0;0YIf  the  algorithm  finds  a word that has distance [3Xstopdist[103X to the code, it
  ends and returns that word, which can be used for further investigations.[133X
  
  [33X[0;0YThe  variable  [3XInfoCoveringRadius[103X  can  be set to [3XPrint[103X to print the maximum
  distance  reached  so  far every 1000 runs. The algorithm can be interrupted
  with  [12Xctrl-C[112X,  allowing the user to look at the word that is currently being
  examined  (called  `current'), or to change the chances that the new word is
  made  permanent  (these are called `staychance' and `downchance'). If one of
  these variables is [22Xi[122X, then it corresponds with a [22Xi[122X in 100 chance.[133X
  
  [33X[0;0YAt  the moment, the algorithm is only useful for codes with small dimension,
  where  small means that the elements of the code fit in the memory. It works
  with  larger  codes,  however,  but  when  you  use  it for codes with large
  dimension,  you  should  be [13Xvery[113X patient. If running the algorithm quits GAP
  (due  to memory problems), you can change the global variable [3XCRMemSize[103X to a
  lower  value.  This  might  cause  the  algorithm to run slower, but without
  quitting  GAP.  The  only  way to find out the best value of [3XCRMemSize[103X is by
  experimenting.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XIncreaseCoveringRadiusLowerBound(C,10);[127X[104X
    [4X[28XNumber of runs: 1000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 2000  best distance so far: 3[128X[104X
    [4X[28XNumber of changes: 100[128X[104X
    [4X[28XNumber of runs: 3000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 4000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 5000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 6000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 7000  best distance so far: 3[128X[104X
    [4X[28XNumber of changes: 200[128X[104X
    [4X[28XNumber of runs: 8000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 9000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 10000  best distance so far: 3[128X[104X
    [4X[28XNumber of changes: 300[128X[104X
    [4X[28XNumber of runs: 11000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 12000  best distance so far: 3[128X[104X
    [4X[28XNumber of runs: 13000  best distance so far: 3[128X[104X
    [4X[28XNumber of changes: 400[128X[104X
    [4X[28XNumber of runs: 14000  best distance so far: 3[128X[104X
    [4X[28Xuser interrupt at... [128X[104X
    [4X[28X#[128X[104X
    [4X[28X# used ctrl-c to break out of execution[128X[104X
    [4X[28X#[128X[104X
    [4X[28X... called from [128X[104X
    [4X[28XIncreaseCoveringRadiusLowerBound( code, -1, current ) called from[128X[104X
    [4X[28X function( arguments ) called from read-eval-loop[128X[104X
    [4X[28XEntering break read-eval-print loop ...[128X[104X
    [4X[28Xyou can 'quit;' to quit to outer loop, or[128X[104X
    [4X[28Xyou can 'return;' to continue[128X[104X
    [4X[26Xbrk>[126X [27Xcurrent;[127X[104X
    [4X[28X[ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ][128X[104X
    [4X[26Xbrk>[126X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-3 ExhaustiveSearchCoveringRadius[101X
  
  [29X[2XExhaustiveSearchCoveringRadius[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XExhaustiveSearchCoveringRadius[110X   does  an  exhaustive  search  to  find  the
  covering  radius of [3XC[103X. Every time a coset leader of a coset with weight [22Xw[122X is
  found, the function tries to find a coset leader of a coset with weight [22Xw+1[122X.
  It  does this by enumerating all words of weight [22Xw+1[122X, and checking whether a
  word is a coset leader. The start weight is the current known lower bound on
  the covering radius.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XExhaustiveSearchCoveringRadius(C);[127X[104X
    [4X[28XTrying 3 ...[128X[104X
    [4X[28X[ 3 .. 5 ][128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-4 GeneralLowerBoundCoveringRadius[101X
  
  [29X[2XGeneralLowerBoundCoveringRadius[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XGeneralLowerBoundCoveringRadius[110X returns a lower bound on the covering radius
  of    [3XC[103X.    It   uses   as   many   functions   which   names   start   with
  [10XLowerBoundCoveringRadius[110X  as possible to find the best known lower bound (at
  least  that  [5XGUAVA[105X knows of) together with tables for the covering radius of
  binary linear codes with length not greater than [22X64[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XGeneralLowerBoundCoveringRadius(C);[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-5 GeneralUpperBoundCoveringRadius[101X
  
  [29X[2XGeneralUpperBoundCoveringRadius[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XGeneralUpperBoundCoveringRadius[110X  returns  an  upper  bound  on  the covering
  radius   of   [3XC[103X.   It   uses  as  many  functions  which  names  start  with
  [10XUpperBoundCoveringRadius[110X  as possible to find the best known upper bound (at
  least that [5XGUAVA[105X knows of).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XGeneralUpperBoundCoveringRadius(C);[127X[104X
    [4X[28X4[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-6 LowerBoundCoveringRadiusSphereCovering[101X
  
  [29X[2XLowerBoundCoveringRadiusSphereCovering[102X( [3Xn[103X, [3XM[103X[, [3XF[103X], [3Xfalse[103X ) [32X function
  
  [33X[0;0YThis     command     can     also     be    called    using    the    syntax
  [10XLowerBoundCoveringRadiusSphereCovering(  n,  r,  [F,]  true  )[110X.  If the last
  argument of [10XLowerBoundCoveringRadiusSphereCovering[110X is [3Xfalse[103X, then it returns
  a  lower  bound  for  the  covering radius of a code of size [3XM[103X and length [3Xn[103X.
  Otherwise,  it  returns a lower bound for the size of a code of length [3Xn[103X and
  covering radius [3Xr[103X.[133X
  
  [33X[0;0Y[3XF[103X  is  the  field  over  which  the  code is defined. If [3XF[103X is omitted, it is
  assumed  that the code is over [22XGF(2)[122X. The bound is computed according to the
  sphere covering bound:[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \cdot V_q(n,r) \geq q^n[133X [124X[133X
  
  
  [33X[0;0Ywhere [22XV_q(n,r)[122X is the size of a sphere of radius [22Xr[122X in [22XGF(q)^n[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize(C);[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusSphereCovering(10,32,GF(2),false);[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusSphereCovering(10,3,GF(2),true);[127X[104X
    [4X[28X6[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-7 LowerBoundCoveringRadiusVanWee1[101X
  
  [29X[2XLowerBoundCoveringRadiusVanWee1[102X( [3Xn[103X, [3XM[103X[, [3XF[103X], [3Xfalse[103X ) [32X function
  
  [33X[0;0YThis     command     can     also     be    called    using    the    syntax
  [10XLowerBoundCoveringRadiusVanWee1(  n, r, [F,] true )[110X. If the last argument of
  [10XLowerBoundCoveringRadiusVanWee1[110X  is [3Xfalse[103X, then it returns a lower bound for
  the  covering radius of a code of size [3XM[103X and length [3Xn[103X. Otherwise, it returns
  a lower bound for the size of a code of length [3Xn[103X and covering radius [3Xr[103X.[133X
  
  [33X[0;0Y[3XF[103X  is  the  field  over  which  the  code is defined. If [3XF[103X is omitted, it is
  assumed that the code is over [22XGF(2)[122X.[133X
  
  [33X[0;0YThe Van Wee bound is an improvement of the sphere covering bound:[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \cdot \left\{ V_q(n,r) - \frac{{n \choose
        r}}{\lceil\frac{n-r}{r+1}\rceil}
        \left(\left\lceil\frac{n+1}{r+1}\right\rceil - \frac{n+1}{r+1}\right)
        \right\} \geq q^n[133X [124X[133X
  
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize(C);[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusVanWee1(10,32,GF(2),false);[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusVanWee1(10,3,GF(2),true);[127X[104X
    [4X[28X6[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-8 LowerBoundCoveringRadiusVanWee2[101X
  
  [29X[2XLowerBoundCoveringRadiusVanWee2[102X( [3Xn[103X, [3XM[103X, [3Xfalse[103X ) [32X function
  
  [33X[0;0YThis     command     can     also     be    called    using    the    syntax
  [10XLowerBoundCoveringRadiusVanWee2(  n,  r  [,true]  )[110X. If the last argument of
  [10XLowerBoundCoveringRadiusVanWee2[110X  is [3Xfalse[103X, then it returns a lower bound for
  the  covering radius of a code of size [3XM[103X and length [3Xn[103X. Otherwise, it returns
  a lower bound for the size of a code of length [3Xn[103X and covering radius [3Xr[103X.[133X
  
  [33X[0;0YThis  bound  only  works  for  binary  codes.  It  is based on the following
  inequality:[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \cdot \frac{\left( \left( V_2(n,2) - \frac{1}{2}(r+2)(r-1) \right)
        V_2(n,r) + \varepsilon V_2(n,r-2) \right)} {(V_2(n,2) -
        \frac{1}{2}(r+2)(r-1) + \varepsilon)} \geq 2^n,[133X [124X[133X
  
  
  [33X[0;0Ywhere[133X
  
  
        [33X[1;6Y[24X[33X[0;0Y\varepsilon = {r+2 \choose 2} \left\lceil {n-r+1 \choose 2} / {r+2
        \choose 2} \right\rceil - {n-r+1 \choose 2}.[133X [124X[133X
  
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize(C);[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusVanWee2(10,32,false);[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusVanWee2(10,3,true);[127X[104X
    [4X[28X7[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-9 LowerBoundCoveringRadiusCountingExcess[101X
  
  [29X[2XLowerBoundCoveringRadiusCountingExcess[102X( [3Xn[103X, [3XM[103X, [3Xfalse[103X ) [32X function
  
  [33X[0;0YThis command can also be called with [10XLowerBoundCoveringRadiusCountingExcess(
  n,      r      [,true]      )[110X.      If      the     last     argument     of
  [10XLowerBoundCoveringRadiusCountingExcess[110X  is  [3Xfalse[103X,  then  it returns a lower
  bound  for  the covering radius of a code of size [3XM[103X and length [3Xn[103X. Otherwise,
  it  returns  a  lower  bound for the size of a code of length [3Xn[103X and covering
  radius [3Xr[103X.[133X
  
  [33X[0;0YThis  bound  only  works  for  binary  codes.  It  is based on the following
  inequality:[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \cdot \left( \rho V_2(n,r) + \varepsilon V_2(n,r-1) \right) \geq
        (\rho + \varepsilon) 2^n,[133X [124X[133X
  
  
  [33X[0;0Ywhere[133X
  
  
        [33X[1;6Y[24X[33X[0;0Y\varepsilon = (r+1) \left\lceil\frac{n+1}{r+1}\right\rceil - (n+1)[133X [124X[133X
  
  
  [33X[0;0Yand[133X
  
  
        [33X[1;6Y[24X[33X[0;0Y\rho = \left\{ \begin{array}{l} n-3+\frac{2}{n}, \ \ \ \ \ \ {\rm if}\
        r = 2\\ n-r-1 , \ \ \ \ \ \ {\rm if}\ r \geq 3 . \end{array} \right.[133X [124X[133X
  
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize(C);[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusCountingExcess(10,32,false);[127X[104X
    [4X[28X0[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusCountingExcess(10,3,true);[127X[104X
    [4X[28X7[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-10 LowerBoundCoveringRadiusEmbedded1[101X
  
  [29X[2XLowerBoundCoveringRadiusEmbedded1[102X( [3Xn[103X, [3XM[103X, [3Xfalse[103X ) [32X function
  
  [33X[0;0YThis command can also be called with [10XLowerBoundCoveringRadiusEmbedded1( n, r
  [,true]  )[110X.  If  the  last  argument of [10XLowerBoundCoveringRadiusEmbedded1[110X is
  'false',  then it returns a lower bound for the covering radius of a code of
  size  [3XM[103X  and length [3Xn[103X. Otherwise, it returns a lower bound for the size of a
  code of length [3Xn[103X and covering radius [3Xr[103X.[133X
  
  [33X[0;0YThis  bound  only  works  for  binary  codes.  It  is based on the following
  inequality:[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \cdot \left( V_2(n,r) - {2r \choose r} \right) \geq 2^n - A( n, 2r+1
        ) {2r \choose r},[133X [124X[133X
  
  
  [33X[0;0Ywhere  [22XA(n,d)[122X denotes the maximal cardinality of a (binary) code of length [22Xn[122X
  and  minimum  distance  [22Xd[122X.  The  function [10XUpperBound[110X is used to compute this
  value.[133X
  
  [33X[0;0YSometimes      [10XLowerBoundCoveringRadiusEmbedded1[110X      is     better     than
  [10XLowerBoundCoveringRadiusEmbedded2[110X, sometimes it is the other way around.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(10,5,GF(2));[127X[104X
    [4X[28Xa  [10,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize(C);[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusEmbedded1(10,32,false);[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusEmbedded1(10,3,true);[127X[104X
    [4X[28X7[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-11 LowerBoundCoveringRadiusEmbedded2[101X
  
  [29X[2XLowerBoundCoveringRadiusEmbedded2[102X( [3Xn[103X, [3XM[103X, [3Xfalse[103X ) [32X function
  
  [33X[0;0YThis command can also be called with [10XLowerBoundCoveringRadiusEmbedded2( n, r
  [,true]  )[110X.  If  the  last  argument of [10XLowerBoundCoveringRadiusEmbedded2[110X is
  'false',  then it returns a lower bound for the covering radius of a code of
  size  [3XM[103X  and length [3Xn[103X. Otherwise, it returns a lower bound for the size of a
  code of length [3Xn[103X and covering radius [3Xr[103X.[133X
  
  [33X[0;0YThis  bound  only  works  for  binary  codes.  It  is based on the following
  inequality:[133X
  
  
        [33X[1;6Y[24X[33X[0;0YM \cdot \left( V_2(n,r) - \frac{3}{2} {2r \choose r} \right) \geq 2^n
        - 2A( n, 2r+1 ) {2r \choose r},[133X [124X[133X
  
  
  [33X[0;0Ywhere  [22XA(n,d)[122X denotes the maximal cardinality of a (binary) code of length [22Xn[122X
  and  minimum  distance  [22Xd[122X.  The  function [10XUpperBound[110X is used to compute this
  value.[133X
  
  [33X[0;0YSometimes      [10XLowerBoundCoveringRadiusEmbedded1[110X      is     better     than
  [10XLowerBoundCoveringRadiusEmbedded2[110X, sometimes it is the other way around.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(15,5,GF(2));[127X[104X
    [4X[28Xa  [15,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XSize(C);[127X[104X
    [4X[28X32[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X6[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusEmbedded2(10,32,false);[127X[104X
    [4X[28X2[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusEmbedded2(10,3,true);[127X[104X
    [4X[28X7[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-12 LowerBoundCoveringRadiusInduction[101X
  
  [29X[2XLowerBoundCoveringRadiusInduction[102X( [3Xn[103X, [3Xr[103X ) [32X function
  
  [33X[0;0Y[10XLowerBoundCoveringRadiusInduction[110X  returns  a  lower bound for the size of a
  code with length [3Xn[103X and covering radius [3Xr[103X.[133X
  
  [33X[0;0YIf [22Xn = 2r+2[122X and [22Xr â‰¥ 1[122X, the returned value is [22X4[122X.[133X
  
  [33X[0;0YIf [22Xn = 2r+3[122X and [22Xr â‰¥ 1[122X, the returned value is [22X7[122X.[133X
  
  [33X[0;0YIf [22Xn = 2r+4[122X and [22Xr â‰¥ 4[122X, the returned value is [22X8[122X.[133X
  
  [33X[0;0YOtherwise, [22X0[122X is returned.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(15,5,GF(2));[127X[104X
    [4X[28Xa  [15,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X5[128X[104X
    [4X[25Xgap>[125X [27XLowerBoundCoveringRadiusInduction(15,6);[127X[104X
    [4X[28X7[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-13 UpperBoundCoveringRadiusRedundancy[101X
  
  [29X[2XUpperBoundCoveringRadiusRedundancy[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XUpperBoundCoveringRadiusRedundancy[110X  returns  the redundancy of [3XC[103X as an upper
  bound for the covering radius of [3XC[103X. [3XC[103X must be a linear code.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(15,5,GF(2));[127X[104X
    [4X[28Xa  [15,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X5[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundCoveringRadiusRedundancy(C);[127X[104X
    [4X[28X10[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-14 UpperBoundCoveringRadiusDelsarte[101X
  
  [29X[2XUpperBoundCoveringRadiusDelsarte[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XUpperBoundCoveringRadiusDelsarte[110X  returns  an  upper  bound for the covering
  radius  of  [3XC[103X. This upper bound is equal to the external distance of [3XC[103X, this
  is the minimum distance of the dual code, if [3XC[103X is a linear code.[133X
  
  [33X[0;0YThis is described in Theorem 11.3.3 of [HP03].[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(15,5,GF(2));[127X[104X
    [4X[28Xa  [15,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X5[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundCoveringRadiusDelsarte(C);[127X[104X
    [4X[28X13[128X[104X
  [4X[32X[104X
  
  [1X7.2-15 UpperBoundCoveringRadiusStrength[101X
  
  [29X[2XUpperBoundCoveringRadiusStrength[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XUpperBoundCoveringRadiusStrength[110X  returns  an  upper  bound for the covering
  radius of [3XC[103X.[133X
  
  [33X[0;0YFirst  the  code  is punctured at the zero coordinates (i.e. the coordinates
  where all codewords have a zero). If the remaining code has [13Xstrength[113X 1 (i.e.
  each  coordinate  contains  each  element  of  the  field an equal number of
  times),  then it returns [22Xfracq-1qm + (n-m)[122X (where [22Xq[122X is the size of the field
  and  [22Xm[122X  is the length of punctured code), otherwise it returns [22Xn[122X. This bound
  works for all codes.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(15,5,GF(2));[127X[104X
    [4X[28Xa  [15,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X5[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundCoveringRadiusStrength(C);[127X[104X
    [4X[28X7[128X[104X
  [4X[32X[104X
  
  [1X7.2-16 UpperBoundCoveringRadiusGriesmerLike[101X
  
  [29X[2XUpperBoundCoveringRadiusGriesmerLike[102X( [3XC[103X ) [32X function
  
  [33X[0;0YThis  function  returns  an  upper bound for the covering radius of [3XC[103X, which
  must be linear, in a Griesmer-like fashion. It returns[133X
  
  
        [33X[1;6Y[24X[33X[0;0Yn - \sum_{i=1}^k \left\lceil \frac{d}{q^i} \right\rceil[133X [124X[133X
  
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=RandomLinearCode(15,5,GF(2));[127X[104X
    [4X[28Xa  [15,5,?] randomly generated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X5[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundCoveringRadiusGriesmerLike(C);[127X[104X
    [4X[28X9[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.2-17 UpperBoundCoveringRadiusCyclicCode[101X
  
  [29X[2XUpperBoundCoveringRadiusCyclicCode[102X( [3XC[103X ) [32X function
  
  [33X[0;0YThis  function  returns  an  upper bound for the covering radius of [3XC[103X, which
  must be a cyclic code. It returns[133X
  
  
        [33X[1;6Y[24X[33X[0;0Yn - k + 1 - \left\lceil \frac{w(g(x))}{2} \right\rceil,[133X [124X[133X
  
  
  [33X[0;0Ywhere [22Xg(x)[122X is the generator polynomial of [3XC[103X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC:=CyclicCodes(15,GF(2))[3];[127X[104X
    [4X[28Xa cyclic [15,12,1..2]1..3 enumerated code over GF(2)[128X[104X
    [4X[25Xgap>[125X [27XCoveringRadius(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XUpperBoundCoveringRadiusCyclicCode(C);[127X[104X
    [4X[28X3[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  
  [1X7.3 [33X[0;0YSpecial matrices in [5XGUAVA[105X[101X[1X[133X[101X
  
  [33X[0;0YThis  section explains functions that work with special matrices [5XGUAVA[105X needs
  for several codes.[133X
  
  [33X[0;0YFirstly,  we  describe  some  matrix generating functions (see [2XKrawtchoukMat[102X
  ([14X7.3-1[114X), [2XGrayMat[102X ([14X7.3-2[114X), [2XSylvesterMat[102X ([14X7.3-3[114X), [2XHadamardMat[102X ([14X7.3-4[114X) and [2XMOLS[102X
  ([14X7.3-11[114X)).[133X
  
  [33X[0;0YNext  we  describe  two functions regarding a standard form of matrices (see
  [2XPutStandardForm[102X ([14X7.3-6[114X) and [2XIsInStandardForm[102X ([14X7.3-7[114X)).[133X
  
  [33X[0;0YThen  we  describe  functions that return a matrix after a manipulation (see
  [2XPermutedCols[102X     ([14X7.3-8[114X),     [2XVerticalConversionFieldMat[102X     ([14X7.3-9[114X)     and
  [2XHorizontalConversionFieldMat[102X ([14X7.3-10[114X)).[133X
  
  [33X[0;0YFinally,  we  describe  functions  that  do  some  tests  on  matrices  (see
  [2XIsLatinSquare[102X ([14X7.3-12[114X) and [2XAreMOLS[102X ([14X7.3-13[114X)).[133X
  
  [1X7.3-1 KrawtchoukMat[101X
  
  [29X[2XKrawtchoukMat[102X( [3Xn[103X, [3Xq[103X ) [32X function
  
  [33X[0;0Y[10XKrawtchoukMat[110X  returns the [22Xn+1[122X by [22Xn+1[122X matrix [22XK=(k_ij)[122X defined by [22Xk_ij=K_i(j)[122X
  for [22Xi,j=0,...,n[122X. [22XK_i(j)[122X is the Krawtchouk number (see [2XKrawtchouk[102X ([14X7.5-6[114X)). [3Xn[103X
  must  be  a  positive  integer and [3Xq[103X a prime power. The Krawtchouk matrix is
  used in the [13XMacWilliams identities[113X, defining the relation between the weight
  distribution  of  a  code  of  length [3Xn[103X over a field of size [3Xq[103X, and its dual
  code.  Each  call  to  [10XKrawtchoukMat[110X  returns a new matrix, so it is safe to
  modify the result.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XPrintArray( KrawtchoukMat( 3, 2 ) );[127X[104X
    [4X[28X[ [   1,   1,   1,   1 ],[128X[104X
    [4X[28X  [   3,   1,  -1,  -3 ],[128X[104X
    [4X[28X  [   3,  -1,  -1,   3 ],[128X[104X
    [4X[28X  [   1,  -1,   1,  -1 ] ][128X[104X
    [4X[25Xgap>[125X [27XC := HammingCode( 3 );; a := WeightDistribution( C );[127X[104X
    [4X[28X[ 1, 0, 0, 7, 7, 0, 0, 1 ][128X[104X
    [4X[25Xgap>[125X [27Xn := WordLength( C );; q := Size( LeftActingDomain( C ) );;[127X[104X
    [4X[25Xgap>[125X [27Xk := Dimension( C );;[127X[104X
    [4X[25Xgap>[125X [27Xq^( -k ) * KrawtchoukMat( n, q ) * a;[127X[104X
    [4X[28X[ 1, 0, 0, 0, 7, 0, 0, 0 ][128X[104X
    [4X[25Xgap>[125X [27XWeightDistribution( DualCode( C ) );[127X[104X
    [4X[28X[ 1, 0, 0, 0, 7, 0, 0, 0 ] [128X[104X
  [4X[32X[104X
  
  [1X7.3-2 GrayMat[101X
  
  [29X[2XGrayMat[102X( [3Xn[103X, [3XF[103X ) [32X function
  
  [33X[0;0Y[10XGrayMat[110X  returns a list of all different vectors (see GAP's [10XVectors[110X command)
  of  length  [3Xn[103X  over  the  field [3XF[103X, using Gray ordering. [3Xn[103X must be a positive
  integer.  This  order  has  the  property  that subsequent vectors differ in
  exactly  one  coordinate.  The  first vector is always the null vector. Each
  call to [10XGrayMat[110X returns a new matrix, so it is safe to modify the result.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XGrayMat(3);[127X[104X
    [4X[28X[ [ 0*Z(2), 0*Z(2), 0*Z(2) ], [ 0*Z(2), 0*Z(2), Z(2)^0 ],[128X[104X
    [4X[28X  [ 0*Z(2), Z(2)^0, Z(2)^0 ], [ 0*Z(2), Z(2)^0, 0*Z(2) ],[128X[104X
    [4X[28X  [ Z(2)^0, Z(2)^0, 0*Z(2) ], [ Z(2)^0, Z(2)^0, Z(2)^0 ],[128X[104X
    [4X[28X  [ Z(2)^0, 0*Z(2), Z(2)^0 ], [ Z(2)^0, 0*Z(2), 0*Z(2) ] ][128X[104X
    [4X[25Xgap>[125X [27XG := GrayMat( 4, GF(4) );; Length(G);[127X[104X
    [4X[28X256          # the length of a GrayMat is always q^n[128X[104X
    [4X[25Xgap>[125X [27XG[101] - G[100];[127X[104X
    [4X[28X[ 0*Z(2), 0*Z(2), Z(2)^0, 0*Z(2) ] [128X[104X
  [4X[32X[104X
  
  [1X7.3-3 SylvesterMat[101X
  
  [29X[2XSylvesterMat[102X( [3Xn[103X ) [32X function
  
  [33X[0;0Y[10XSylvesterMat[110X returns the [22XnÃ— n[122X Sylvester matrix of order [3Xn[103X. This is a special
  case   of   the  Hadamard  matrices  (see  [2XHadamardMat[102X  ([14X7.3-4[114X)).  For  this
  construction,  [3Xn[103X  must  be a power of [22X2[122X. Each call to [10XSylvesterMat[110X returns a
  new matrix, so it is safe to modify the result.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XPrintArray(SylvesterMat(2));[127X[104X
    [4X[28X[ [   1,   1 ],[128X[104X
    [4X[28X  [   1,  -1 ] ][128X[104X
    [4X[25Xgap>[125X [27XPrintArray( SylvesterMat(4) );[127X[104X
    [4X[28X[ [   1,   1,   1,   1 ],[128X[104X
    [4X[28X  [   1,  -1,   1,  -1 ],[128X[104X
    [4X[28X  [   1,   1,  -1,  -1 ],[128X[104X
    [4X[28X  [   1,  -1,  -1,   1 ] ] [128X[104X
  [4X[32X[104X
  
  [1X7.3-4 HadamardMat[101X
  
  [29X[2XHadamardMat[102X( [3Xn[103X ) [32X function
  
  [33X[0;0Y[10XHadamardMat[110X  returns  a  Hadamard  matrix of order [3Xn[103X. This is an [22XnÃ— n[122X matrix
  with  the  property  that  the  matrix multiplied by its transpose returns [3Xn[103X
  times  the  identity  matrix. This is only possible for [22Xn=1, n=2[122X or in cases
  where [3Xn[103X is a multiple of [22X4[122X. If the matrix does not exist or is not known (as
  of  1998),  [10XHadamardMat[110X  returns  an  error.  A large number of construction
  methods  is known to create these matrices for different orders. [10XHadamardMat[110X
  makes   use   of   two  construction  methods  (the  Paley  Type  I  and  II
  constructions,  and the Sylvester construction -- see [2XSylvesterMat[102X ([14X7.3-3[114X)).
  These  methods  cover  most of the possible Hadamard matrices, although some
  special  algorithms have not been implemented yet. The following orders less
  than  [22X100[122X  do not yet have an implementation for a Hadamard matrix in [5XGUAVA[105X:
  [22X52, 92[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XC := HadamardMat(8);; PrintArray(C);[127X[104X
    [4X[28X[ [   1,   1,   1,   1,   1,   1,   1,   1 ],[128X[104X
    [4X[28X  [   1,  -1,   1,  -1,   1,  -1,   1,  -1 ],[128X[104X
    [4X[28X  [   1,   1,  -1,  -1,   1,   1,  -1,  -1 ],[128X[104X
    [4X[28X  [   1,  -1,  -1,   1,   1,  -1,  -1,   1 ],[128X[104X
    [4X[28X  [   1,   1,   1,   1,  -1,  -1,  -1,  -1 ],[128X[104X
    [4X[28X  [   1,  -1,   1,  -1,  -1,   1,  -1,   1 ],[128X[104X
    [4X[28X  [   1,   1,  -1,  -1,  -1,  -1,   1,   1 ],[128X[104X
    [4X[28X  [   1,  -1,  -1,   1,  -1,   1,   1,  -1 ] ][128X[104X
    [4X[25Xgap>[125X [27XC * TransposedMat(C) = 8 * IdentityMat( 8, 8 );[127X[104X
    [4X[28Xtrue [128X[104X
  [4X[32X[104X
  
  [1X7.3-5 VandermondeMat[101X
  
  [29X[2XVandermondeMat[102X( [3XX[103X, [3Xa[103X ) [32X function
  
  [33X[0;0YThe  function  [10XVandermondeMat[110X  returns  the  [22X(a+1)Ã— n[122X matrix of powers [22Xx_i^j[122X
  where  [3XX[103X  is  a  list  of  elements of a field, [22XX={ x_1,...,x_n}[122X, and [3Xa[103X is a
  non-negative integer.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM:=VandermondeMat([Z(5),Z(5)^2,Z(5)^0,Z(5)^3],2);[127X[104X
    [4X[28X[ [ Z(5)^0, Z(5), Z(5)^2 ], [ Z(5)^0, Z(5)^2, Z(5)^0 ],[128X[104X
    [4X[28X  [ Z(5)^0, Z(5)^0, Z(5)^0 ], [ Z(5)^0, Z(5)^3, Z(5)^2 ] ][128X[104X
    [4X[25Xgap>[125X [27XDisplay(M);[127X[104X
    [4X[28X 1 2 4[128X[104X
    [4X[28X 1 4 1[128X[104X
    [4X[28X 1 1 1[128X[104X
    [4X[28X 1 3 4[128X[104X
  [4X[32X[104X
  
  [1X7.3-6 PutStandardForm[101X
  
  [29X[2XPutStandardForm[102X( [3XM[103X[, [3Xidleft[103X] ) [32X function
  
  [33X[0;0YWe  say  that  a [22XkÃ— n[122X matrix is in [13Xstandard form[113X if it is equal to the block
  matrix  [22X(I | A)[122X, for some [22XkÃ— (n-k)[122X matrix [22XA[122X and where [22XI[122X is the [22XkÃ— k[122X identity
  matrix.  It  follows  from  a  basis  result in linear algebra that, after a
  possible  permutation of the columns, using elementary row operations, every
  matrix  can  be reduced to standard form. [10XPutStandardForm[110X puts a matrix [3XM[103X in
  standard  form,  and  returns  the  permutation needed to do so. [3Xidleft[103X is a
  boolean that sets the position of the identity matrix in [3XM[103X. (The default for
  [3Xidleft[103X is `true'.) If [3Xidleft[103X is set to `true', the identity matrix is put on
  the  left side of [3XM[103X. Otherwise, it is put at the right side. (This option is
  useful  when  putting  a  check  matrix  of  a code into standard form.) The
  function  [10XBaseMat[110X  also  returns a similar standard form, but does not apply
  column permutations. The rows of the matrix still span the same vector space
  after  [10XBaseMat[110X,  but  after calling [10XPutStandardForm[110X, this is not necessarily
  true.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := Z(2)*[[1,0,0,1],[0,0,1,1]];; PrintArray(M);[127X[104X
    [4X[28X[ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],[128X[104X
    [4X[28X  [  0*Z(2),  0*Z(2),    Z(2),    Z(2) ] ][128X[104X
    [4X[25Xgap>[125X [27XPutStandardForm(M);                   # identity at the left side[127X[104X
    [4X[28X(2,3)[128X[104X
    [4X[25Xgap>[125X [27XPrintArray(M);[127X[104X
    [4X[28X[ [    Z(2),  0*Z(2),  0*Z(2),    Z(2) ],[128X[104X
    [4X[28X  [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ][128X[104X
    [4X[25Xgap>[125X [27XPutStandardForm(M, false);            # identity at the right side[127X[104X
    [4X[28X(1,4,3)[128X[104X
    [4X[25Xgap>[125X [27XPrintArray(M);[127X[104X
    [4X[28X[ [  0*Z(2),    Z(2),    Z(2),  0*Z(2) ],[128X[104X
    [4X[28X  [  0*Z(2),    Z(2),  0*Z(2),    Z(2) ] ][128X[104X
    [4X[25Xgap>[125X [27XC := BestKnownLinearCode( 23, 12, GF(2) );[127X[104X
    [4X[28Xa linear [23,12,7]3 punctured code[128X[104X
    [4X[25Xgap>[125X [27XG:=MutableCopyMat(GeneratorMat(C));;[127X[104X
    [4X[25Xgap>[125X [27XPutStandardForm(G);[127X[104X
    [4X[28X()[128X[104X
    [4X[25Xgap>[125X [27XDisplay(G);[127X[104X
    [4X[28X 1 . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1[128X[104X
    [4X[28X . 1 . . . . . . . . . . 1 1 1 1 1 . . 1 . . .[128X[104X
    [4X[28X . . 1 . . . . . . . . . 1 1 . 1 . . 1 . 1 . 1[128X[104X
    [4X[28X . . . 1 . . . . . . . . 1 1 . . . 1 1 1 . 1 .[128X[104X
    [4X[28X . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 . 1[128X[104X
    [4X[28X . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1 1[128X[104X
    [4X[28X . . . . . . 1 . . . . . . . 1 1 . . 1 1 . 1 1[128X[104X
    [4X[28X . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 . .[128X[104X
    [4X[28X . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 1 .[128X[104X
    [4X[28X . . . . . . . . . 1 . . . . 1 . 1 1 . 1 1 1 .[128X[104X
    [4X[28X . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1 1[128X[104X
    [4X[28X . . . . . . . . . . . 1 . 1 . 1 1 1 . . . 1 1[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.3-7 IsInStandardForm[101X
  
  [29X[2XIsInStandardForm[102X( [3XM[103X[, [3Xidleft[103X] ) [32X function
  
  [33X[0;0Y[10XIsInStandardForm[110X  determines  if  [3XM[103X is in standard form. [3Xidleft[103X is a boolean
  that   indicates   the   position  of  the  identity  matrix  in  [3XM[103X,  as  in
  [10XPutStandardForm[110X  (see  [2XPutStandardForm[102X  ([14X7.3-6[114X)). [10XIsInStandardForm[110X checks if
  the  identity  matrix  is  at  the left side of [3XM[103X, otherwise if it is at the
  right side. The elements of [3XM[103X may be elements of any field.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XIsInStandardForm(IdentityMat(7, GF(2)));[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XIsInStandardForm([[1, 1, 0], [1, 0, 1]], false);[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XIsInStandardForm([[1, 3, 2, 7]]);[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XIsInStandardForm(HadamardMat(4));[127X[104X
    [4X[28Xfalse [128X[104X
  [4X[32X[104X
  
  [1X7.3-8 PermutedCols[101X
  
  [29X[2XPermutedCols[102X( [3XM[103X, [3XP[103X ) [32X function
  
  [33X[0;0Y[10XPermutedCols[110X returns a matrix [3XM[103X with a permutation [3XP[103X applied to its columns.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := [[1,2,3,4],[1,2,3,4]];; PrintArray(M);[127X[104X
    [4X[28X[ [  1,  2,  3,  4 ],[128X[104X
    [4X[28X  [  1,  2,  3,  4 ] ][128X[104X
    [4X[25Xgap>[125X [27XPrintArray(PermutedCols(M, (1,2,3)));[127X[104X
    [4X[28X[ [  3,  1,  2,  4 ],[128X[104X
    [4X[28X  [  3,  1,  2,  4 ] ] [128X[104X
  [4X[32X[104X
  
  [1X7.3-9 VerticalConversionFieldMat[101X
  
  [29X[2XVerticalConversionFieldMat[102X( [3XM[103X, [3XF[103X ) [32X function
  
  [33X[0;0Y[10XVerticalConversionFieldMat[110X  returns the matrix [3XM[103X with its elements converted
  from  a field [22XF=GF(q^m)[122X, [22Xq[122X prime, to a field [22XGF(q)[122X. Each element is replaced
  by  its  representation  over  the  latter  field,  placed vertically in the
  matrix, using the [22XGF(p)[122X-vector space isomorphism[133X
  
  
        [33X[1;6Y[24X[33X[0;0Y[...] : GF(q)\rightarrow GF(p)^m,[133X [124X[133X
  
  
  [33X[0;0Ywith [22Xq=p^m[122X.[133X
  
  [33X[0;0YIf [3XM[103X is a [22Xk[122X by [22Xn[122X matrix, the result is a [22Xkâ‹… m Ã— n[122X matrix, since each element
  of [22XGF(q^m)[122X can be represented in [22XGF(q)[122X using [22Xm[122X elements.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := Z(9)*[[1,2],[2,1]];; PrintArray(M);[127X[104X
    [4X[28X[ [    Z(3^2),  Z(3^2)^5 ],[128X[104X
    [4X[28X  [  Z(3^2)^5,    Z(3^2) ] ][128X[104X
    [4X[25Xgap>[125X [27XDefaultField( Flat(M) );[127X[104X
    [4X[28XGF(3^2)[128X[104X
    [4X[25Xgap>[125X [27XVCFM := VerticalConversionFieldMat( M, GF(9) );; PrintArray(VCFM);[127X[104X
    [4X[28X[ [  0*Z(3),  0*Z(3) ],[128X[104X
    [4X[28X  [  Z(3)^0,    Z(3) ],[128X[104X
    [4X[28X  [  0*Z(3),  0*Z(3) ],[128X[104X
    [4X[28X  [    Z(3),  Z(3)^0 ] ][128X[104X
    [4X[25Xgap>[125X [27XDefaultField( Flat(VCFM) );[127X[104X
    [4X[28XGF(3) [128X[104X
  [4X[32X[104X
  
  [33X[0;0YA      similar     function     is     [10XHorizontalConversionFieldMat[110X     (see
  [2XHorizontalConversionFieldMat[102X ([14X7.3-10[114X)).[133X
  
  [1X7.3-10 HorizontalConversionFieldMat[101X
  
  [29X[2XHorizontalConversionFieldMat[102X( [3XM[103X, [3XF[103X ) [32X function
  
  [33X[0;0Y[10XHorizontalConversionFieldMat[110X   returns   the  matrix  [3XM[103X  with  its  elements
  converted from a field [22XF=GF(q^m)[122X, [22Xq[122X prime, to a field [22XGF(q)[122X. Each element is
  replaced by its representation over the latter field, placed horizontally in
  the matrix.[133X
  
  [33X[0;0YIf  [3XM[103X  is  a  [22Xk  Ã— n[122X matrix, the result is a [22XkÃ— mÃ— nâ‹… m[122X matrix. The new word
  length  of  the  resulting  code  is  equal to [22Xnâ‹… m[122X, because each element of
  [22XGF(q^m)[122X  can  be represented in [22XGF(q)[122X using [22Xm[122X elements. The new dimension is
  equal  to  [22XkÃ— m[122X because the new matrix should be a basis for the same number
  of vectors as the old one.[133X
  
  [33X[0;0Y[10XConversionFieldCode[110X  uses  horizontal  conversion  to  convert  a  code (see
  [2XConversionFieldCode[102X ([14X6.1-15[114X)).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := Z(9)*[[1,2],[2,1]];; PrintArray(M);[127X[104X
    [4X[28X[ [    Z(3^2),  Z(3^2)^5 ],[128X[104X
    [4X[28X  [  Z(3^2)^5,    Z(3^2) ] ][128X[104X
    [4X[25Xgap>[125X [27XDefaultField( Flat(M) );[127X[104X
    [4X[28XGF(3^2)[128X[104X
    [4X[25Xgap>[125X [27XHCFM := HorizontalConversionFieldMat(M, GF(9));; PrintArray(HCFM);[127X[104X
    [4X[28X[ [  0*Z(3),  Z(3)^0,  0*Z(3),    Z(3) ],[128X[104X
    [4X[28X  [  Z(3)^0,  Z(3)^0,    Z(3),    Z(3) ],[128X[104X
    [4X[28X  [  0*Z(3),    Z(3),  0*Z(3),  Z(3)^0 ],[128X[104X
    [4X[28X  [    Z(3),    Z(3),  Z(3)^0,  Z(3)^0 ] ][128X[104X
    [4X[25Xgap>[125X [27XDefaultField( Flat(HCFM) );[127X[104X
    [4X[28XGF(3) [128X[104X
  [4X[32X[104X
  
  [33X[0;0YA      similar      function      is     [10XVerticalConversionFieldMat[110X     (see
  [2XVerticalConversionFieldMat[102X ([14X7.3-9[114X)).[133X
  
  [1X7.3-11 MOLS[101X
  
  [29X[2XMOLS[102X( [3Xq[103X[, [3Xn[103X] ) [32X function
  
  [33X[0;0Y[10XMOLS[110X  returns  a list of [3Xn[103X [13XMutually Orthogonal Latin Squares[113X (MOLS). A [13XLatin
  square[113X  of  order  [3Xq[103X  is a [22XqÃ— q[122X matrix whose entries are from a set [22XF_q[122X of [3Xq[103X
  distinct  symbols  ([5XGUAVA[105X  uses the integers from [22X0[122X to [3Xq[103X) such that each row
  and each column of the matrix contains each symbol exactly once.[133X
  
  [33X[0;0YA  set  of  Latin  squares  is a set of MOLS if and only if for each pair of
  Latin  squares  in  this set, every ordered pair of elements that are in the
  same position in these matrices occurs exactly once.[133X
  
  [33X[0;0Y[3Xn[103X must be less than [3Xq[103X. If [3Xn[103X is omitted, two MOLS are returned. If [3Xq[103X is not a
  prime  power,  at most [22X2[122X MOLS can be created. For all values of [3Xq[103X with [22Xq > 2[122X
  and  [22Xq  â‰   6[122X, a list of MOLS can be constructed. However, [5XGUAVA[105X does not yet
  construct  MOLS  for  [22Xqâ‰¡ 2 mod 4[122X. If it is not possible to construct [3Xn[103X MOLS,
  the function returns `false'.[133X
  
  [33X[0;0YMOLS are used to create [3Xq[103X-ary codes (see [2XMOLSCode[102X ([14X5.1-4[114X)).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := MOLS( 4, 3 );;PrintArray( M[1] );[127X[104X
    [4X[28X[ [  0,  1,  2,  3 ],[128X[104X
    [4X[28X  [  1,  0,  3,  2 ],[128X[104X
    [4X[28X  [  2,  3,  0,  1 ],[128X[104X
    [4X[28X  [  3,  2,  1,  0 ] ][128X[104X
    [4X[25Xgap>[125X [27XPrintArray( M[2] );[127X[104X
    [4X[28X[ [  0,  2,  3,  1 ],[128X[104X
    [4X[28X  [  1,  3,  2,  0 ],[128X[104X
    [4X[28X  [  2,  0,  1,  3 ],[128X[104X
    [4X[28X  [  3,  1,  0,  2 ] ][128X[104X
    [4X[25Xgap>[125X [27XPrintArray( M[3] );[127X[104X
    [4X[28X[ [  0,  3,  1,  2 ],[128X[104X
    [4X[28X  [  1,  2,  0,  3 ],[128X[104X
    [4X[28X  [  2,  1,  3,  0 ],[128X[104X
    [4X[28X  [  3,  0,  2,  1 ] ][128X[104X
    [4X[25Xgap>[125X [27XMOLS( 12, 3 );[127X[104X
    [4X[28Xfalse [128X[104X
  [4X[32X[104X
  
  [1X7.3-12 IsLatinSquare[101X
  
  [29X[2XIsLatinSquare[102X( [3XM[103X ) [32X function
  
  [33X[0;0Y[10XIsLatinSquare[110X determines if a matrix [3XM[103X is a Latin square. For a Latin square
  of  size  [22XnÃ—  n[122X, each row and each column contains all the integers [22X1,dots,n[122X
  exactly once.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XIsLatinSquare([[1,2],[2,1]]);[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XIsLatinSquare([[1,2,3],[2,3,1],[1,3,2]]);[127X[104X
    [4X[28Xfalse [128X[104X
  [4X[32X[104X
  
  [1X7.3-13 AreMOLS[101X
  
  [29X[2XAreMOLS[102X( [3XL[103X ) [32X function
  
  [33X[0;0Y[10XAreMOLS[110X  determines  if  [3XL[103X  is  a  list of mutually orthogonal Latin squares
  (MOLS).  For each pair of Latin squares in this list, the function checks if
  each  ordered  pair  of  elements  that  are  in  the same position in these
  matrices  occurs  exactly  once.  The  function  [10XMOLS[110X creates MOLS (see [2XMOLS[102X
  ([14X7.3-11[114X)).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := MOLS(4,2);[127X[104X
    [4X[28X[ [ [ 0, 1, 2, 3 ], [ 1, 0, 3, 2 ], [ 2, 3, 0, 1 ], [ 3, 2, 1, 0 ] ],[128X[104X
    [4X[28X  [ [ 0, 2, 3, 1 ], [ 1, 3, 2, 0 ], [ 2, 0, 1, 3 ], [ 3, 1, 0, 2 ] ] ][128X[104X
    [4X[25Xgap>[125X [27XAreMOLS(M);[127X[104X
    [4X[28Xtrue [128X[104X
  [4X[32X[104X
  
  
  [1X7.4 [33X[0;0YSome functions related to the norm of a code[133X[101X
  
  [33X[0;0YIn  this  section,  some functions that can be used to compute the norm of a
  code  and  to  decide upon its normality are discussed. Typically, these are
  applied  to  binary  linear  codes.  The  definitions  of  this section were
  introduced in Graham and Sloane [GS85].[133X
  
  [1X7.4-1 CoordinateNorm[101X
  
  [29X[2XCoordinateNorm[102X( [3XC[103X, [3Xcoord[103X ) [32X function
  
  [33X[0;0Y[10XCoordinateNorm[110X  returns  the  norm of [3XC[103X with respect to coordinate [3Xcoord[103X. If
  [22XC_a  =  { c âˆˆ C | c_coord = a }[122X, then the norm of [3XC[103X with respect to [3Xcoord[103X is
  defined as[133X
  
  
        [33X[1;6Y[24X[33X[0;0Y\max_{v \in GF(q)^n} \sum_{a=1}^q d(x,C_a),[133X [124X[133X
  
  
  [33X[0;0Ywith the convention that [22Xd(x,C_a) = n[122X if [22XC_a[122X is empty.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XCoordinateNorm( HammingCode( 3, GF(2) ), 3 );[127X[104X
    [4X[28X3 [128X[104X
  [4X[32X[104X
  
  [1X7.4-2 CodeNorm[101X
  
  [29X[2XCodeNorm[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XCodeNorm[110X returns the norm of [3XC[103X. The [13Xnorm[113X of a code is defined as the minimum
  of the norms for the respective coordinates of the code. In effect, for each
  coordinate  [10XCoordinateNorm[110X  is  called,  and  the  minimum of the calculated
  numbers is returned.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XCodeNorm( HammingCode( 3, GF(2) ) );[127X[104X
    [4X[28X3 [128X[104X
  [4X[32X[104X
  
  [1X7.4-3 IsCoordinateAcceptable[101X
  
  [29X[2XIsCoordinateAcceptable[102X( [3XC[103X, [3Xcoord[103X ) [32X function
  
  [33X[0;0Y[10XIsCoordinateAcceptable[110X   returns   `true'   if  coordinate  [3Xcoord[103X  of  [3XC[103X  is
  acceptable.  A  coordinate is called [13Xacceptable[113X if the norm of the code with
  respect to that coordinate is not more than two times the covering radius of
  the code plus one.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XIsCoordinateAcceptable( HammingCode( 3, GF(2) ), 3 );[127X[104X
    [4X[28Xtrue [128X[104X
  [4X[32X[104X
  
  [1X7.4-4 GeneralizedCodeNorm[101X
  
  [29X[2XGeneralizedCodeNorm[102X( [3XC[103X, [3Xsubcode1[103X, [3Xsubscode2[103X, [3X...[103X, [3Xsubcodek[103X ) [32X function
  
  [33X[0;0Y[10XGeneralizedCodeNorm[110X returns the [3Xk[103X-norm of [3XC[103X with respect to [3Xk[103X subcodes.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xc := RepetitionCode( 7, GF(2) );;[127X[104X
    [4X[25Xgap>[125X [27Xham := HammingCode( 3, GF(2) );;[127X[104X
    [4X[25Xgap>[125X [27Xd := EvenWeightSubcode( ham );;[127X[104X
    [4X[25Xgap>[125X [27Xe := ConstantWeightSubcode( ham, 3 );;[127X[104X
    [4X[25Xgap>[125X [27XGeneralizedCodeNorm( ham, c, d, e );[127X[104X
    [4X[28X4 [128X[104X
  [4X[32X[104X
  
  [1X7.4-5 IsNormalCode[101X
  
  [29X[2XIsNormalCode[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XIsNormalCode[110X  returns  `true' if [3XC[103X is normal. A code is called [13Xnormal[113X if the
  norm  of the code is not more than two times the covering radius of the code
  plus  one.  Almost  all codes are normal, however some (non-linear) abnormal
  codes have been found.[133X
  
  [33X[0;0YOften,  it  is  difficult  to  find out whether a code is normal, because it
  involves  computing  the  covering  radius.  However, [10XIsNormalCode[110X uses much
  information  from the literature (in particular, [GS85]) about normality for
  certain code parameters.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XIsNormalCode( HammingCode( 3, GF(2) ) );[127X[104X
    [4X[28Xtrue [128X[104X
  [4X[32X[104X
  
  
  [1X7.5 [33X[0;0YMiscellaneous functions[133X[101X
  
  [33X[0;0YIn  this  section  we describe several vector space functions [5XGUAVA[105X uses for
  constructing codes or performing calculations with codes.[133X
  
  [33X[0;0YIn  this  section, some new miscellaneous functions are described, including
  weight  enumerators,  the  MacWilliams-transform  and  affinity  and  almost
  affinity of codes.[133X
  
  [1X7.5-1 CodeWeightEnumerator[101X
  
  [29X[2XCodeWeightEnumerator[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XCodeWeightEnumerator[110X returns a polynomial of the following form:[133X
  
  
        [33X[1;6Y[24X[33X[0;0Yf(x) = \sum_{i=0}^{n} A_i x^i,[133X [124X[133X
  
  
  [33X[0;0Ywhere [22XA_i[122X is the number of codewords in [3XC[103X with weight [22Xi[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XCodeWeightEnumerator( ElementsCode( [ [ 0,0,0 ], [ 0,0,1 ],[127X[104X
    [4X[25X>[125X [27X[ 0,1,1 ], [ 1,1,1 ] ], GF(2) ) );[127X[104X
    [4X[28Xx^3 + x^2 + x + 1[128X[104X
    [4X[25Xgap>[125X [27XCodeWeightEnumerator( HammingCode( 3, GF(2) ) );[127X[104X
    [4X[28Xx^7 + 7*x^4 + 7*x^3 + 1 [128X[104X
  [4X[32X[104X
  
  [1X7.5-2 CodeDistanceEnumerator[101X
  
  [29X[2XCodeDistanceEnumerator[102X( [3XC[103X, [3Xw[103X ) [32X function
  
  [33X[0;0Y[10XCodeDistanceEnumerator[110X returns a polynomial of the following form:[133X
  
  
        [33X[1;6Y[24X[33X[0;0Yf(x) = \sum_{i=0}^{n} B_i x^i,[133X [124X[133X
  
  
  [33X[0;0Ywhere [22XB_i[122X is the number of codewords with distance [22Xi[122X to [3Xw[103X.[133X
  
  [33X[0;0YIf  [3Xw[103X is a codeword, then [10XCodeDistanceEnumerator[110X returns the same polynomial
  as [10XCodeWeightEnumerator[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XCodeDistanceEnumerator( HammingCode( 3, GF(2) ),[0,0,0,0,0,0,1] );[127X[104X
    [4X[28Xx^6 + 3*x^5 + 4*x^4 + 4*x^3 + 3*x^2 + x[128X[104X
    [4X[25Xgap>[125X [27XCodeDistanceEnumerator( HammingCode( 3, GF(2) ),[1,1,1,1,1,1,1] );[127X[104X
    [4X[28Xx^7 + 7*x^4 + 7*x^3 + 1 # `[1,1,1,1,1,1,1]' $\in$ `HammingCode( 3, GF(2 ) )'[128X[104X
  [4X[32X[104X
  
  [1X7.5-3 CodeMacWilliamsTransform[101X
  
  [29X[2XCodeMacWilliamsTransform[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XCodeMacWilliamsTransform[110X returns a polynomial of the following form:[133X
  
  
        [33X[1;6Y[24X[33X[0;0Yf(x) = \sum_{i=0}^{n} C_i x^i,[133X [124X[133X
  
  
  [33X[0;0Ywhere [22XC_i[122X is the number of codewords with weight [22Xi[122X in the [13Xdual[113X code of [3XC[103X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XCodeMacWilliamsTransform( HammingCode( 3, GF(2) ) );[127X[104X
    [4X[28X7*x^4 + 1 [128X[104X
  [4X[32X[104X
  
  [1X7.5-4 CodeDensity[101X
  
  [29X[2XCodeDensity[102X( [3XC[103X ) [32X function
  
  [33X[0;0Y[10XCodeDensity[110X returns the [13Xdensity[113X of [3XC[103X. The density of a code is defined as[133X
  
  
        [33X[1;6Y[24X[33X[0;0Y\frac{M \cdot V_q(n,t)}{q^n},[133X [124X[133X
  
  
  [33X[0;0Ywhere  [22XM[122X is the size of the code, [22XV_q(n,t)[122X is the size of a sphere of radius
  [22Xt[122X  in [22XGF(q^n)[122X (which may be computed using [10XSphereContent[110X), [22Xt[122X is the covering
  radius of the code and [22Xn[122X is the length of the code.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XCodeDensity( HammingCode( 3, GF(2) ) );[127X[104X
    [4X[28X1[128X[104X
    [4X[25Xgap>[125X [27XCodeDensity( ReedMullerCode( 1, 4 ) );[127X[104X
    [4X[28X14893/2048 [128X[104X
  [4X[32X[104X
  
  [1X7.5-5 SphereContent[101X
  
  [29X[2XSphereContent[102X( [3Xn[103X, [3Xt[103X, [3XF[103X ) [32X function
  
  [33X[0;0Y[10XSphereContent[110X  returns the content of a ball of radius [3Xt[103X around an arbitrary
  element  of  the  vectorspace [22XF^n[122X. This is the cardinality of the set of all
  elements of [22XF^n[122X that are at distance (see [2XDistanceCodeword[102X ([14X3.6-2[114X) less than
  or equal to [3Xt[103X from an element of [22XF^n[122X.[133X
  
  [33X[0;0YIn  the  context  of  codes,  the function is used to determine if a code is
  perfect.  A  code  is  [13Xperfect[113X  if  spheres of radius [22Xt[122X around all codewords
  partition  the  whole  ambient vector space, where [13Xt[113X is the number of errors
  the code can correct.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XSphereContent( 15, 0, GF(2) );[127X[104X
    [4X[28X1    # Only one word with distance 0, which is the word itself[128X[104X
    [4X[25Xgap>[125X [27XSphereContent( 11, 3, GF(4) );[127X[104X
    [4X[28X4984[128X[104X
    [4X[25Xgap>[125X [27XC := HammingCode(5);[127X[104X
    [4X[28Xa linear [31,26,3]1 Hamming (5,2) code over GF(2)[128X[104X
    [4X[28X#the minimum distance is 3, so the code can correct one error[128X[104X
    [4X[25Xgap>[125X [27X( SphereContent( 31, 1, GF(2) ) * Size(C) ) = 2 ^ 31;[127X[104X
    [4X[28Xtrue [128X[104X
  [4X[32X[104X
  
  [1X7.5-6 Krawtchouk[101X
  
  [29X[2XKrawtchouk[102X( [3Xk[103X, [3Xi[103X, [3Xn[103X, [3Xq[103X ) [32X function
  
  [33X[0;0Y[10XKrawtchouk[110X  returns the Krawtchouk number [22XK_k(i)[122X. [3Xq[103X must be a prime power, [3Xn[103X
  must  be  a  positive integer, [3Xk[103X must be a non-negative integer less then or
  equal  to  [3Xn[103X  and  [3Xi[103X  can  be any integer. (See [2XKrawtchoukMat[102X ([14X7.3-1[114X)). This
  number is the value at [22Xx=i[122X of the polynomial[133X
  
  
        [33X[1;6Y[24X[33X[0;0YK_k^{n,q}(x) =\sum_{j=0}^n (-1)^j(q-1)^{k-j}b(x,j)b(n-x,k-j),[133X [124X[133X
  
  
  [33X[0;0Ywhere  $b(v,u)=u!/(v!(v-u)!)$  is  the  binomial  coefficient  if  $u,v$ are
  integers. For more properties of these polynomials, see [MS83].[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XKrawtchouk( 2, 0, 3, 2);[127X[104X
    [4X[28X3 [128X[104X
  [4X[32X[104X
  
  [1X7.5-7 PrimitiveUnityRoot[101X
  
  [29X[2XPrimitiveUnityRoot[102X( [3XF[103X, [3Xn[103X ) [32X function
  
  [33X[0;0Y[10XPrimitiveUnityRoot[110X  returns  a  primitive [3Xn[103X-th root of unity in an extension
  field  of  [3XF[103X. This is a finite field element [22Xa[122X with the property [22Xa^n=1[122X in [3XF[103X,
  and [3Xn[103X is the smallest integer such that this equality holds.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XPrimitiveUnityRoot( GF(2), 15 );[127X[104X
    [4X[28XZ(2^4)[128X[104X
    [4X[25Xgap>[125X [27Xlast^15;[127X[104X
    [4X[28XZ(2)^0[128X[104X
    [4X[25Xgap>[125X [27XPrimitiveUnityRoot( GF(8), 21 );[127X[104X
    [4X[28XZ(2^6)^3 [128X[104X
  [4X[32X[104X
  
  [1X7.5-8 PrimitivePolynomialsNr[101X
  
  [29X[2XPrimitivePolynomialsNr[102X( [3Xn[103X, [3XF[103X ) [32X function
  
  [33X[0;0Y[10XPrimitivePolynomialsNr[110X  returns  the  number of irreducible polynomials over
  [22XF=GF(q)[122X  of degree [3Xn[103X with (maximum) period [22Xq^n-1[122X. (According to a theorem of
  S. Golomb, this is [22XÏ•(p^n-1)/n[122X.)[133X
  
  [33X[0;0YSee      also      the      GAP      function     [10XRandomPrimitivePolynomial[110X,
  [2XRandomPrimitivePolynomial[102X ([14X8.2-2[114X).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XPrimitivePolynomialsNr(3,4);[127X[104X
    [4X[28X12[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.5-9 IrreduciblePolynomialsNr[101X
  
  [29X[2XIrreduciblePolynomialsNr[102X( [3Xn[103X, [3XF[103X ) [32X function
  
  [33X[0;0Y[10XPrimitivePolynomialsNr[110X  returns  the  number of irreducible polynomials over
  [22XF=GF(q)[122X of degree [3Xn[103X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XIrreduciblePolynomialsNr(3,4);[127X[104X
    [4X[28X20[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.5-10 MatrixRepresentationOfElement[101X
  
  [29X[2XMatrixRepresentationOfElement[102X( [3Xa[103X, [3XF[103X ) [32X function
  
  [33X[0;0YHere  [3XF[103X  is  either a finite extension of the ``base field'' [22XGF(p)[122X or of the
  rationals  [22XQ}[122X, and [22Xaâˆˆ F[122X. The command [10XMatrixRepresentationOfElement[110X returns a
  matrix representation of [3Xa[103X over the base field.[133X
  
  [33X[0;0YIf  the  element  [3Xa[103X  is  defined  over  the  base  field then it returns the
  corresponding [22X1Ã— 1[122X matrix.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xa:=Random(GF(4));[127X[104X
    [4X[28X0*Z(2)[128X[104X
    [4X[25Xgap>[125X [27XM:=MatrixRepresentationOfElement(a,GF(4));; Display(M);[127X[104X
    [4X[28X .[128X[104X
    [4X[25Xgap>[125X [27Xa:=Random(GF(4));[127X[104X
    [4X[28XZ(2^2)[128X[104X
    [4X[25Xgap>[125X [27XM:=MatrixRepresentationOfElement(a,GF(4));; Display(M);[127X[104X
    [4X[28X . 1[128X[104X
    [4X[28X 1 1[128X[104X
    [4X[28Xgap>[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.5-11 ReciprocalPolynomial[101X
  
  [29X[2XReciprocalPolynomial[102X( [3XP[103X ) [32X function
  
  [33X[0;0Y[10XReciprocalPolynomial[110X  returns  the  [13Xreciprocal[113X  of  polynomial  [3XP[103X. This is a
  polynomial  with coefficients of [3XP[103X in the reverse order. So if [22XP=a_0 + a_1 X
  +  ...  + a_n X^n[122X, the reciprocal polynomial is [22XP'=a_n + a_n-1 X + ... + a_0
  X^n[122X.[133X
  
  [33X[0;0YThis command can also be called using the syntax [10XReciprocalPolynomial( P , n
  )[110X.  In this form, the number of coefficients of [3XP[103X is assumed to be less than
  or  equal  to  [22Xn+1[122X  (with zero coefficients added in the highest degrees, if
  necessary). Therefore, the reciprocal polynomial also has degree [22Xn+1[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XP := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );[127X[104X
    [4X[28XZ(3)^0+x_1^2-x_1^3[128X[104X
    [4X[25Xgap>[125X [27XRecP := ReciprocalPolynomial( P );[127X[104X
    [4X[28X-Z(3)^0+x_1+x_1^3[128X[104X
    [4X[25Xgap>[125X [27XReciprocalPolynomial( RecP ) = P;[127X[104X
    [4X[28Xtrue [128X[104X
    [4X[25Xgap>[125X [27XP := UnivariatePolynomial( GF(3), Z(3)^0 * [1,0,1,2] );[127X[104X
    [4X[28XZ(3)^0+x_1^2-x_1^3[128X[104X
    [4X[25Xgap>[125X [27XReciprocalPolynomial( P, 6 );[127X[104X
    [4X[28X-x_1^3+x_1^4+x_1^6[128X[104X
  [4X[32X[104X
  
  [1X7.5-12 CyclotomicCosets[101X
  
  [29X[2XCyclotomicCosets[102X( [3Xq[103X, [3Xn[103X ) [32X function
  
  [33X[0;0Y[10XCyclotomicCosets[110X  returns  the cyclotomic cosets of [22Xq mod n[122X. [3Xq[103X and [3Xn[103X must be
  relatively  prime.  Each  of  the elements of the returned list is a list of
  integers  that belong to one cyclotomic coset. A [22Xq[122X-cyclotomic coset of [22Xs mod
  n[122X  is  a  set  of  the  form [22X{s,sq,sq^2,...,sq^r-1}[122X, where [22Xr[122X is the smallest
  positive  integer  such  that  [22Xsq^r-s[122X is [22X0 mod n[122X. In other words, each coset
  contains  all  multiplications  of  the coset representative by [22Xq mod n[122X. The
  coset  representative  is  the  smallest  integer that isn't in the previous
  cosets.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XCyclotomicCosets( 2, 15 );[127X[104X
    [4X[28X[ [ 0 ], [ 1, 2, 4, 8 ], [ 3, 6, 12, 9 ], [ 5, 10 ],[128X[104X
    [4X[28X  [ 7, 14, 13, 11 ] ][128X[104X
    [4X[25Xgap>[125X [27XCyclotomicCosets( 7, 6 );[127X[104X
    [4X[28X[ [ 0 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ] ] [128X[104X
  [4X[32X[104X
  
  [1X7.5-13 WeightHistogram[101X
  
  [29X[2XWeightHistogram[102X( [3XC[103X[, [3Xh[103X] ) [32X function
  
  [33X[0;0YThe  function  [10XWeightHistogram[110X  plots  a histogram of weights in code [3XC[103X. The
  maximum  length  of a column is [3Xh[103X. Default value for [3Xh[103X is [22X1/3[122X of the size of
  the  screen.  The  number  that  appears  at the top of the histogram is the
  maximum value of the list of weights.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XH := HammingCode(2, GF(5));[127X[104X
    [4X[28Xa linear [6,4,3]1 Hamming (2,5) code over GF(5)[128X[104X
    [4X[25Xgap>[125X [27XWeightDistribution(H);[127X[104X
    [4X[28X[ 1, 0, 0, 80, 120, 264, 160 ][128X[104X
    [4X[25Xgap>[125X [27XWeightHistogram(H);[127X[104X
    [4X[28X264----------------[128X[104X
    [4X[28X               *[128X[104X
    [4X[28X               *[128X[104X
    [4X[28X               *[128X[104X
    [4X[28X               *[128X[104X
    [4X[28X               *  *[128X[104X
    [4X[28X            *  *  *[128X[104X
    [4X[28X         *  *  *  *[128X[104X
    [4X[28X         *  *  *  *[128X[104X
    [4X[28X+--------+--+--+--+--[128X[104X
    [4X[28X0  1  2  3  4  5  6 [128X[104X
  [4X[32X[104X
  
  [1X7.5-14 MultiplicityInList[101X
  
  [29X[2XMultiplicityInList[102X( [3XL[103X, [3Xa[103X ) [32X function
  
  [33X[0;0YThis  is a very simple list command which returns how many times a occurs in
  L.  It returns 0 if a is not in L. (The GAP command [10XCollected[110X does not quite
  handle this "extreme" case.)[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XL:=[1,2,3,4,3,2,1,5,4,3,2,1];;[127X[104X
    [4X[25Xgap>[125X [27XMultiplicityInList(L,1);[127X[104X
    [4X[28X3[128X[104X
    [4X[25Xgap>[125X [27XMultiplicityInList(L,6);[127X[104X
    [4X[28X0[128X[104X
  [4X[32X[104X
  
  [1X7.5-15 MostCommonInList[101X
  
  [29X[2XMostCommonInList[102X( [3XL[103X ) [32X function
  
  [33X[0;0YInput: a list L[133X
  
  [33X[0;0YOutput: an a in L which occurs at least as much as any other in L[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XL:=[1,2,3,4,3,2,1,5,4,3,2,1];;[127X[104X
    [4X[25Xgap>[125X [27XMostCommonInList(L);[127X[104X
    [4X[28X1[128X[104X
  [4X[32X[104X
  
  [1X7.5-16 RotateList[101X
  
  [29X[2XRotateList[102X( [3XL[103X ) [32X function
  
  [33X[0;0YInput: a list L[133X
  
  [33X[0;0YOutput: a list L' which is the cyclic rotation of L (to the right)[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XL:=[1,2,3,4];;[127X[104X
    [4X[25Xgap>[125X [27XRotateList(L);[127X[104X
    [4X[28X[2,3,4,1][128X[104X
  [4X[32X[104X
  
  [1X7.5-17 CirculantMatrix[101X
  
  [29X[2XCirculantMatrix[102X( [3Xk[103X, [3XL[103X ) [32X function
  
  [33X[0;0YInput: integer k, a list L of length n[133X
  
  [33X[0;0YOutput: kxn matrix whose rows are cyclic rotations of the list L[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xk:=3; L:=[1,2,3,4];;[127X[104X
    [4X[25Xgap>[125X [27XM:=CirculantMatrix(k,L);;[127X[104X
    [4X[25Xgap>[125X [27XDisplay(M);[127X[104X
  [4X[32X[104X
  
  
  [1X7.6 [33X[0;0YMiscellaneous polynomial functions[133X[101X
  
  [33X[0;0YIn  this  section  we describe several multivariate polynomial GAP functions
  [5XGUAVA[105X uses for constructing codes or performing calculations with codes.[133X
  
  [1X7.6-1 MatrixTransformationOnMultivariatePolynomial [101X
  
  [29X[2XMatrixTransformationOnMultivariatePolynomial [102X( [3XA[103X, [3Xf[103X, [3XR[103X ) [32X function
  
  [33X[0;0Y[3XA[103X  is  an [22XnÃ— n[122X matrix with entries in a field [22XF[122X, [3XR[103X is a polynomial ring of [22Xn[122X
  variables,  say  [22XF[x_1,...,x_n][122X,  and  [3Xf[103X  is  a polynomial in [3XR[103X. Returns the
  composition [22Xfâˆ˜ A[122X.[133X
  
  [1X7.6-2 DegreeMultivariatePolynomial[101X
  
  [29X[2XDegreeMultivariatePolynomial[102X( [3Xf[103X, [3XR[103X ) [32X function
  
  [33X[0;0YThis  command  takes  two  arguments,  [3Xf[103X, a multivariate polynomial, and [3XR[103X a
  polynomial  ring  over a field [22XF[122X containing [3Xf[103X, say [22XR=F[x_1,x_2,...,x_n][122X. The
  output is simply the maximum degrees of all the monomials occurring in [3Xf[103X.[133X
  
  [33X[0;0YThis command can be used to compute the degree of an affine plane curve.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XF:=GF(11);;[127X[104X
    [4X[25Xgap>[125X [27XR2:=PolynomialRing(F,2);[127X[104X
    [4X[28XPolynomialRing(..., [ x_1, x_2 ])[128X[104X
    [4X[25Xgap>[125X [27Xvars:=IndeterminatesOfPolynomialRing(R2);;[127X[104X
    [4X[25Xgap>[125X [27Xx:=vars[1];; y:=vars[2];;[127X[104X
    [4X[25Xgap>[125X [27Xpoly:=y^2-x*(x^2-1);;[127X[104X
    [4X[25Xgap>[125X [27XDegreeMultivariatePolynomial(poly,R2);[127X[104X
    [4X[28X3[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.6-3 DegreesMultivariatePolynomial[101X
  
  [29X[2XDegreesMultivariatePolynomial[102X( [3Xf[103X, [3XR[103X ) [32X function
  
  [33X[0;0YReturns  a list of information about the multivariate polynomial [3Xf[103X. Nice for
  other programs but mostly unreadable by GAP users.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XF:=GF(11);;[127X[104X
    [4X[25Xgap>[125X [27XR2:=PolynomialRing(F,2);[127X[104X
    [4X[28XPolynomialRing(..., [ x_1, x_2 ])[128X[104X
    [4X[25Xgap>[125X [27Xvars:=IndeterminatesOfPolynomialRing(R2);;[127X[104X
    [4X[25Xgap>[125X [27Xx:=vars[1];; y:=vars[2];;[127X[104X
    [4X[25Xgap>[125X [27Xpoly:=y^2-x*(x^2-1);;[127X[104X
    [4X[25Xgap>[125X [27XDegreesMultivariatePolynomial(poly,R2);[127X[104X
    [4X[28X[ [ [ x_1, x_1, 1 ], [ x_1, x_2, 0 ] ], [ [ x_2^2, x_1, 0 ], [ x_2^2, x_2, 2 ] ],[128X[104X
    [4X[28X  [ [ x_1^3, x_1, 3 ], [ x_1^3, x_2, 0 ] ] ][128X[104X
    [4X[28Xgap>[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.6-4 CoefficientMultivariatePolynomial[101X
  
  [29X[2XCoefficientMultivariatePolynomial[102X( [3Xf[103X, [3Xvar[103X, [3Xpower[103X, [3XR[103X ) [32X function
  
  [33X[0;0YThe   command  [10XCoefficientMultivariatePolynomial[110X  takes  four  arguments:  a
  multivariant  polynomial  [3Xf[103X,  a  variable  name [3Xvar[103X, an integer [3Xpower[103X, and a
  polynomial  ring  [3XR[103X  containing  [3Xf[103X.  For  example,  if  [3Xf[103X  is a multivariate
  polynomial  in  [22XR[122X  = [22XF[122X[[22Xx_1,x_2,...,x_n[122X] then [3Xvar[103X must be one of the [22Xx_i[122X. The
  output is the coefficient of [22Xx_i^power[122X in [3Xf[103X.[133X
  
  [33X[0;0Y(Not sure if [22XF[122X needs to be a field in fact ...)[133X
  
  [33X[0;0YRelated to the GAP command [10XPolynomialCoefficientsPolynomial[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XF:=GF(11);;[127X[104X
    [4X[25Xgap>[125X [27XR2:=PolynomialRing(F,2);[127X[104X
    [4X[28XPolynomialRing(..., [ x_1, x_2 ])[128X[104X
    [4X[25Xgap>[125X [27Xvars:=IndeterminatesOfPolynomialRing(R2);;[127X[104X
    [4X[25Xgap>[125X [27Xx:=vars[1];; y:=vars[2];;[127X[104X
    [4X[25Xgap>[125X [27Xpoly:=y^2-x*(x^2-1);;[127X[104X
    [4X[25Xgap>[125X [27XPolynomialCoefficientsOfPolynomial(poly,x);[127X[104X
    [4X[28X[ x_2^2, Z(11)^0, 0*Z(11), -Z(11)^0 ][128X[104X
    [4X[25Xgap>[125X [27XPolynomialCoefficientsOfPolynomial(poly,y);[127X[104X
    [4X[28X[ -x_1^3+x_1, 0*Z(11), Z(11)^0 ][128X[104X
    [4X[25Xgap>[125X [27XCoefficientMultivariatePolynomial(poly,y,0,R2);[127X[104X
    [4X[28X-x_1^3+x_1[128X[104X
    [4X[25Xgap>[125X [27XCoefficientMultivariatePolynomial(poly,y,1,R2);[127X[104X
    [4X[28X0*Z(11)[128X[104X
    [4X[25Xgap>[125X [27XCoefficientMultivariatePolynomial(poly,y,2,R2);[127X[104X
    [4X[28XZ(11)^0[128X[104X
    [4X[25Xgap>[125X [27XCoefficientMultivariatePolynomial(poly,x,0,R2);[127X[104X
    [4X[28Xx_2^2[128X[104X
    [4X[25Xgap>[125X [27XCoefficientMultivariatePolynomial(poly,x,1,R2);[127X[104X
    [4X[28XZ(11)^0[128X[104X
    [4X[25Xgap>[125X [27XCoefficientMultivariatePolynomial(poly,x,2,R2);[127X[104X
    [4X[28X0*Z(11)[128X[104X
    [4X[25Xgap>[125X [27XCoefficientMultivariatePolynomial(poly,x,3,R2);[127X[104X
    [4X[28X-Z(11)^0[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.6-5 SolveLinearSystem[101X
  
  [29X[2XSolveLinearSystem[102X( [3XL[103X, [3Xvars[103X ) [32X function
  
  [33X[0;0YInput: [3XL[103X is a list of linear forms in the variables [3Xvars[103X.[133X
  
  [33X[0;0YOutput: the solution of the system, if its unique.[133X
  
  [33X[0;0YThe  procedure  is  straightforward:  Find the associated matrix [22XA[122X, find the
  "constant vector" [22Xb[122X, and solve [22XA*v=b[122X. No error checking is performed.[133X
  
  [33X[0;0YRelated to the GAP command [10XSolutionMat( A, b )[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XF:=GF(11);;[127X[104X
    [4X[25Xgap>[125X [27XR2:=PolynomialRing(F,2);[127X[104X
    [4X[28XPolynomialRing(..., [ x_1, x_2 ])[128X[104X
    [4X[25Xgap>[125X [27Xvars:=IndeterminatesOfPolynomialRing(R2);;[127X[104X
    [4X[25Xgap>[125X [27Xx:=vars[1];; y:=vars[2];;[127X[104X
    [4X[25Xgap>[125X [27Xf:=3*y-3*x+1;; g:=-5*y+2*x-7;;[127X[104X
    [4X[25Xgap>[125X [27Xsoln:=SolveLinearSystem([f,g],[x,y]);[127X[104X
    [4X[28X[ Z(11)^3, Z(11)^2 ][128X[104X
    [4X[25Xgap>[125X [27XValue(f,[x,y],soln); # checking okay[127X[104X
    [4X[28X0*Z(11)[128X[104X
    [4X[25Xgap>[125X [27XValue(g,[x,y],col); # checking okay[127X[104X
    [4X[28X0*Z(11)[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.6-6 GuavaVersion[101X
  
  [29X[2XGuavaVersion[102X(  ) [32X function
  
  [33X[0;0YReturns the current version of Guava. Same as [10Xguava\_version()[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XGuavaVersion();[127X[104X
    [4X[28X"3.11"[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.6-7 ZechLog[101X
  
  [29X[2XZechLog[102X( [3Xx[103X, [3Xb[103X, [3XF[103X ) [32X function
  
  [33X[0;0YReturns  the  Zech  log  of  x  to  base b, ie the i such that $x+1=b^i$, so
  $y+z=y(1+z/y)=b^k$,   where   k=Log(y,b)+ZechLog(z/y,b)  and  b  must  be  a
  primitive element of F.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XF:=GF(11);; l := One(F);;[127X[104X
    [4X[25Xgap>[125X [27XZechLog(2*l,8*l,F);[127X[104X
    [4X[28X-24[128X[104X
    [4X[25Xgap>[125X [27X8*l+l;(2*l)^(-24);[127X[104X
    [4X[28XZ(11)^6[128X[104X
    [4X[28XZ(11)^6[128X[104X
    [4X[28X[128X[104X
  [4X[32X[104X
  
  [1X7.6-8 CoefficientToPolynomial[101X
  
  [29X[2XCoefficientToPolynomial[102X( [3Xcoeffs[103X, [3XR[103X ) [32X function
  
  [33X[0;0YThe  function  [10XCoefficientToPolynomial[110X  returns  the  degree  [22Xd-1[122X polynomial
  [22Xc_0+c_1x+...+c_d-1x^d-1[122X,  where  [3Xcoeffs[103X  is  a  list of elements of a field,
  [22Xcoeffs={ c_0,...,c_d-1}[122X, and [3XR[103X is a univariate polynomial ring.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XF:=GF(11);[127X[104X
    [4X[28XGF(11)[128X[104X
    [4X[25Xgap>[125X [27XR1:=PolynomialRing(F,["a"]);;[127X[104X
    [4X[25Xgap>[125X [27Xvar1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;[127X[104X
    [4X[25Xgap>[125X [27Xcoeffs:=Z(11)^0*[1,2,3,4];[127X[104X
    [4X[28X[ Z(11)^0, Z(11), Z(11)^8, Z(11)^2 ][128X[104X
    [4X[25Xgap>[125X [27XCoefficientToPolynomial(coeffs,R1);[127X[104X
    [4X[28XZ(11)^2*a^3+Z(11)^8*a^2+Z(11)*a+Z(11)^0[128X[104X
  [4X[32X[104X
  
  [1X7.6-9 DegreesMonomialTerm[101X
  
  [29X[2XDegreesMonomialTerm[102X( [3Xm[103X, [3XR[103X ) [32X function
  
  [33X[0;0YThe  function  [10XDegreesMonomialTerm[110X returns the list of degrees to which each
  variable  in  the  multivariate  polynomial ring [3XR[103X occurs in the monomial [3Xm[103X,
  where [3Xcoeffs[103X is a list of elements of a field.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XF:=GF(11);[127X[104X
    [4X[28XGF(11)[128X[104X
    [4X[25Xgap>[125X [27XR1:=PolynomialRing(F,["a"]);;[127X[104X
    [4X[25Xgap>[125X [27Xvar1:=IndeterminatesOfPolynomialRing(R1);; a:=var1[1];;[127X[104X
    [4X[25Xgap>[125X [27Xb:=X(F,"b",var1);[127X[104X
    [4X[28Xb[128X[104X
    [4X[25Xgap>[125X [27Xvar2:=Concatenation(var1,[b]);[127X[104X
    [4X[28X[ a, b ][128X[104X
    [4X[25Xgap>[125X [27XR2:=PolynomialRing(F,var2);[127X[104X
    [4X[28XPolynomialRing(..., [ a, b ])[128X[104X
    [4X[25Xgap>[125X [27Xc:=X(F,"c",var2);[127X[104X
    [4X[28Xc[128X[104X
    [4X[25Xgap>[125X [27Xvar3:=Concatenation(var2,[c]);[127X[104X
    [4X[28X[ a, b, c ][128X[104X
    [4X[25Xgap>[125X [27XR3:=PolynomialRing(F,var3);[127X[104X
    [4X[28XPolynomialRing(..., [ a, b, c ])[128X[104X
    [4X[25Xgap>[125X [27Xm:=b^3*c^7;[127X[104X
    [4X[28Xb^3*c^7[128X[104X
    [4X[25Xgap>[125X [27XDegreesMonomialTerm(m,R3);[127X[104X
    [4X[28X[ 0, 3, 7 ][128X[104X
  [4X[32X[104X
  
  [1X7.6-10 DivisorsMultivariatePolynomial[101X
  
  [29X[2XDivisorsMultivariatePolynomial[102X( [3Xf[103X, [3XR[103X ) [32X function
  
  [33X[0;0YThe  function  [10XDivisorsMultivariatePolynomial[110X returns the list of polynomial
  divisors  of  [3Xf[103X in the multivariate polynomial ring [3XR[103X with coefficients in a
  field.  This  program  uses a simple but slow algorithm (see Joachim von zur
  Gathen,  JÃ¼rgen  Gerhard,  [GG03],  exercise 16.10) which first converts the
  multivariate  polynomial  [3Xf[103X to an associated univariate polynomial [22Xf^*[122X, then
  [10XFactors[110X  [22Xf^*[122X,  and  finally  converts these univariate factors back into the
  multivariate  polynomial  factors  of [3Xf[103X. Since [10XFactors[110X is non-deterministic,
  [10XDivisorsMultivariatePolynomial[110X is non-deterministic as well.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XR2:=PolynomialRing(GF(3),["x1","x2"]);[127X[104X
    [4X[28XPolynomialRing(..., [ x1, x2 ])[128X[104X
    [4X[25Xgap>[125X [27Xvars:=IndeterminatesOfPolynomialRing(R2);[127X[104X
    [4X[28X[ x1, x2 ][128X[104X
    [4X[25Xgap>[125X [27Xx2:=vars[2];[127X[104X
    [4X[28Xx2[128X[104X
    [4X[25Xgap>[125X [27Xx1:=vars[1];[127X[104X
    [4X[28Xx1[128X[104X
    [4X[25Xgap>[125X [27Xf:=x1^3+x2^3;;[127X[104X
    [4X[25Xgap>[125X [27XDivisorsMultivariatePolynomial(f,R2);[127X[104X
    [4X[28X[ x1+x2, x1+x2, x1+x2 ][128X[104X
  [4X[32X[104X
  
