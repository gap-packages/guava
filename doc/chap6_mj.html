<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<title>GAP (guava) - Chapter 6: Manipulating Codes</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap6"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap6.html">[MathJax off]</a></p>
<p><a id="X866FC1117814B64D" name="X866FC1117814B64D"></a></p>
<div class="ChapSects"><a href="chap6_mj.html#X866FC1117814B64D">6 <span class="Heading">Manipulating Codes</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X8271A4697FDA97B2">6.1 <span class="Heading">
Functions that Generate a New Code from a Given Code
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X794679BE7F9EB5C1">6.1-1 ExtendedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7E6E4DDA79574FDB">6.1-2 PuncturedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X87691AB67FF5621B">6.1-3 EvenWeightSubcode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X79577EB27BE8524B">6.1-4 PermutedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X87E5849784BC60D2">6.1-5 ExpurgatedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8134BE2B8478BE8A">6.1-6 AugmentedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7B0A6E1F82686B43">6.1-7 RemovedElementsCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X784E1255874FCA8A">6.1-8 AddedElementsCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X81CBEAFF7B9DE6EF">6.1-9 ShortenedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7A5D5419846FC867">6.1-10 LengthenedCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7982D699803ECD0F">6.1-11 SubCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X809376187C1525AA">6.1-12 ResidueCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7E92DC9581F96594">6.1-13 ConstructionBCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X799B12F085ACB609">6.1-14 DualCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X81FE1F387DFCCB22">6.1-15 ConversionFieldCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X82D18907800FE3D9">6.1-16 TraceCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8799F4BF81B0842B">6.1-17 CosetCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X873EA5EE85699832">6.1-18 ConstantWeightSubcode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7AA203A380BC4C79">6.1-19 StandardFormCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7EF49A257D6DB53B">6.1-20 PiecewiseConstantCode</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap6_mj.html#X7964BF0081CC8352">6.2 <span class="Heading">
Functions that Generate a New Code from Two or More Given Codes
</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X79E00D3A8367D65A">6.2-1 DirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X86E9D6DE7F1A07E6">6.2-2 UUVCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7BFBBA5784C293C1">6.2-3 DirectProductCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X78F0B1BC81FB109C">6.2-4 IntersectionCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X8228A1F57A29B8F4">6.2-5 UnionCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7A85F8AF8154D387">6.2-6 ExtendedDirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7E17107686A845DB">6.2-7 AmalgamatedDirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7D8981AF7DFE9814">6.2-8 BlockwiseDirectSumCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7C37D467791CE99B">6.2-9 ConstructionXCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X7B50943B8014134F">6.2-10 ConstructionXXCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X790C614985BFAE16">6.2-11 BZCode</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap6_mj.html#X820327D6854A50B5">6.2-12 BZCodeNC</a></span>
</div></div>
</div>

<h3>6 <span class="Heading">Manipulating Codes</span></h3>

<p>In this chapter we describe several functions <strong class="pkg">GUAVA</strong> uses to manipulate codes. Some of the best codes are obtained by starting with for example a BCH code, and manipulating it.</p>

<p>In some cases, it is faster to perform calculations with a manipulated code than to use the original code. For example, if the dimension of the code is larger than half the word length, it is generally faster to compute the weight distribution by first calculating the weight distribution of the dual code than by directly calculating the weight distribution of the original code. The size of the dual code is smaller in these cases.</p>

<p>Because <strong class="pkg">GUAVA</strong> keeps all information in a code record, in some cases the information can be preserved after manipulations. Therefore, computations do not always have to start from scratch.</p>

<p>In Section <a href="chap6_mj.html#X8271A4697FDA97B2"><span class="RefLink">6.1</span></a>, we describe functions that take a code with certain parameters, modify it in some way and return a different code (see <code class="func">ExtendedCode</code> (<a href="chap6_mj.html#X794679BE7F9EB5C1"><span class="RefLink">6.1-1</span></a>), <code class="func">PuncturedCode</code> (<a href="chap6_mj.html#X7E6E4DDA79574FDB"><span class="RefLink">6.1-2</span></a>), <code class="func">EvenWeightSubcode</code> (<a href="chap6_mj.html#X87691AB67FF5621B"><span class="RefLink">6.1-3</span></a>), <code class="func">PermutedCode</code> (<a href="chap6_mj.html#X79577EB27BE8524B"><span class="RefLink">6.1-4</span></a>), <code class="func">ExpurgatedCode</code> (<a href="chap6_mj.html#X87E5849784BC60D2"><span class="RefLink">6.1-5</span></a>), <code class="func">AugmentedCode</code> (<a href="chap6_mj.html#X8134BE2B8478BE8A"><span class="RefLink">6.1-6</span></a>), <code class="func">RemovedElementsCode</code> (<a href="chap6_mj.html#X7B0A6E1F82686B43"><span class="RefLink">6.1-7</span></a>), <code class="func">AddedElementsCode</code> (<a href="chap6_mj.html#X784E1255874FCA8A"><span class="RefLink">6.1-8</span></a>), <code class="func">ShortenedCode</code> (<a href="chap6_mj.html#X81CBEAFF7B9DE6EF"><span class="RefLink">6.1-9</span></a>), <code class="func">LengthenedCode</code> (<a href="chap6_mj.html#X7A5D5419846FC867"><span class="RefLink">6.1-10</span></a>), <code class="func">ResidueCode</code> (<a href="chap6_mj.html#X809376187C1525AA"><span class="RefLink">6.1-12</span></a>), <code class="func">ConstructionBCode</code> (<a href="chap6_mj.html#X7E92DC9581F96594"><span class="RefLink">6.1-13</span></a>), <code class="func">DualCode</code> (<a href="chap6_mj.html#X799B12F085ACB609"><span class="RefLink">6.1-14</span></a>), <code class="func">ConversionFieldCode</code> (<a href="chap6_mj.html#X81FE1F387DFCCB22"><span class="RefLink">6.1-15</span></a>), <code class="func">ConstantWeightSubcode</code> (<a href="chap6_mj.html#X873EA5EE85699832"><span class="RefLink">6.1-18</span></a>), <code class="func">StandardFormCode</code> (<a href="chap6_mj.html#X7AA203A380BC4C79"><span class="RefLink">6.1-19</span></a>) and <code class="func">CosetCode</code> (<a href="chap6_mj.html#X8799F4BF81B0842B"><span class="RefLink">6.1-17</span></a>)). In Section <a href="chap6_mj.html#X7964BF0081CC8352"><span class="RefLink">6.2</span></a>, we describe functions that generate a new code out of two codes (see <code class="func">DirectSumCode</code> (<a href="chap6_mj.html#X79E00D3A8367D65A"><span class="RefLink">6.2-1</span></a>), <code class="func">UUVCode</code> (<a href="chap6_mj.html#X86E9D6DE7F1A07E6"><span class="RefLink">6.2-2</span></a>), <code class="func">DirectProductCode</code> (<a href="chap6_mj.html#X7BFBBA5784C293C1"><span class="RefLink">6.2-3</span></a>), <code class="func">IntersectionCode</code> (<a href="chap6_mj.html#X78F0B1BC81FB109C"><span class="RefLink">6.2-4</span></a>) and <code class="func">UnionCode</code> (<a href="chap6_mj.html#X8228A1F57A29B8F4"><span class="RefLink">6.2-5</span></a>)).</p>

<p><a id="X8271A4697FDA97B2" name="X8271A4697FDA97B2"></a></p>

<h4>6.1 <span class="Heading">
Functions that Generate a New Code from a Given Code
</span></h4>

<p><a id="X794679BE7F9EB5C1" name="X794679BE7F9EB5C1"></a></p>

<h5>6.1-1 ExtendedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtendedCode</code>( <var class="Arg">C</var>[, <var class="Arg">i</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">ExtendedCode</code> extends the code <var class="Arg">C</var> <var class="Arg">i</var> times and returns the result. <var class="Arg">i</var> is equal to <span class="SimpleMath">\(1\)</span> by default. Extending is done by adding a parity check bit after the last coordinate. The coordinates of all codewords now add up to zero. In the binary case, each codeword has even weight.</p>

<p>The word length increases by <var class="Arg">i</var>. The size of the code remains the same. In the binary case, the minimum distance increases by one if it was odd. In other cases, that is not always true.</p>

<p>A cyclic code in general is no longer cyclic after extending.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := HammingCode( 3, GF(2) );</span>
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := ExtendedCode( C1 );</span>
a linear [8,4,4]2 extended code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEquivalent( C2, ReedMullerCode( 1, 3 ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( AsSSortedList( C2 ), WeightCodeword );</span>
[ 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3 := EvenWeightSubcode( C1 );</span>
a linear [7,3,4]2..3 even weight subcode 
</pre></div>

<p>To undo extending, call <code class="code">PuncturedCode</code> (see <code class="func">PuncturedCode</code> (<a href="chap6_mj.html#X7E6E4DDA79574FDB"><span class="RefLink">6.1-2</span></a>)). The function <code class="code">EvenWeightSubcode</code> (see <code class="func">EvenWeightSubcode</code> (<a href="chap6_mj.html#X87691AB67FF5621B"><span class="RefLink">6.1-3</span></a>)) also returns a related code with only even weights, but without changing its word length.</p>

<p><a id="X7E6E4DDA79574FDB" name="X7E6E4DDA79574FDB"></a></p>

<h5>6.1-2 PuncturedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PuncturedCode</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">PuncturedCode</code> punctures <var class="Arg">C</var> in the last column, and returns the result. Puncturing is done simply by cutting off the last column from each codeword. This means the word length decreases by one. The minimum distance in general also decrease by one.</p>

<p>This command can also be called with the syntax <code class="code">PuncturedCode( C, L )</code>. In this case, <code class="code">PuncturedCode</code> punctures <var class="Arg">C</var> in the columns specified by <var class="Arg">L</var>, a list of integers. All columns specified by <var class="Arg">L</var> are omitted from each codeword. If <span class="SimpleMath">\(l\)</span> is the length of <var class="Arg">L</var> (so the number of removed columns), the word length decreases by <span class="SimpleMath">\(l\)</span>. The minimum distance can also decrease by <span class="SimpleMath">\(l\)</span> or less.</p>

<p>Puncturing a cyclic code in general results in a non-cyclic code. If the code is punctured in all the columns where a word of minimal weight is unequal to zero, the dimension of the resulting code decreases.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := BCHCode( 15, 5, GF(2) );</span>
a cyclic [15,7,5]3..5 BCH code, delta=5, b=1 over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := PuncturedCode( C1 );</span>
a linear [14,7,4]3..5 punctured code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExtendedCode( C2 ) = C1;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PuncturedCode( C1, [1,2,3,4,5,6,7] );</span>
a linear [8,7,1]1 punctured code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PuncturedCode( WholeSpaceCode( 4, GF(5) ) );</span>
a linear [3,3,1]0 punctured code  # The dimension decreased from 4 to 3 
</pre></div>

<p><code class="code">ExtendedCode</code> extends the code again (see <code class="func">ExtendedCode</code> (<a href="chap6_mj.html#X794679BE7F9EB5C1"><span class="RefLink">6.1-1</span></a>)), although in general this does not result in the old code.</p>

<p><a id="X87691AB67FF5621B" name="X87691AB67FF5621B"></a></p>

<h5>6.1-3 EvenWeightSubcode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EvenWeightSubcode</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">EvenWeightSubcode</code> returns the even weight subcode of <var class="Arg">C</var>, consisting of all codewords of <var class="Arg">C</var> with even weight. If <var class="Arg">C</var> is a linear code and contains words of odd weight, the resulting code has a dimension of one less. The minimum distance always increases with one if it was odd. If <var class="Arg">C</var> is a binary cyclic code, and <span class="SimpleMath">\(g(x)\)</span> is its generator polynomial, the even weight subcode either has generator polynomial <span class="SimpleMath">\(g(x)\)</span> (if <span class="SimpleMath">\(g(x)\)</span> is divisible by <span class="SimpleMath">\(x-1\)</span>) or <span class="SimpleMath">\(g(x)\cdot (x-1)\)</span> (if no factor <span class="SimpleMath">\(x-1\)</span> was present in <span class="SimpleMath">\(g(x)\)</span>). So the even weight subcode is again cyclic.</p>

<p>Of course, if all codewords of <var class="Arg">C</var> are already of even weight, the returned code is equal to <var class="Arg">C</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := EvenWeightSubcode( BCHCode( 8, 4, GF(3) ) );</span>
an (8,33,4..8)3..8 even weight subcode
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List( AsSSortedList( C1 ), WeightCodeword );</span>
[ 0, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 4, 4, 8, 6, 4, 6, 8, 4, 4, 
  4, 6, 4, 6, 8, 4, 6, 8 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EvenWeightSubcode( ReedMullerCode( 1, 3 ) );</span>
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2) 
</pre></div>

<p><code class="code">ExtendedCode</code> also returns a related code of only even weights, but without reducing its dimension (see <code class="func">ExtendedCode</code> (<a href="chap6_mj.html#X794679BE7F9EB5C1"><span class="RefLink">6.1-1</span></a>)).</p>

<p><a id="X79577EB27BE8524B" name="X79577EB27BE8524B"></a></p>

<h5>6.1-4 PermutedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PermutedCode</code>( <var class="Arg">C</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">PermutedCode</code> returns <var class="Arg">C</var> after column permutations. <var class="Arg">L</var> (in GAP disjoint cycle notation) is the permutation to be executed on the columns of <var class="Arg">C</var>. If <var class="Arg">C</var> is cyclic, the result in general is no longer cyclic. If a permutation results in the same code as <var class="Arg">C</var>, this permutation belongs to the automorphism group of <var class="Arg">C</var> (see <code class="func">AutomorphismGroup</code> (<a href="chap4_mj.html#X87677B0787B4461A"><span class="RefLink">4.4-3</span></a>)). In any case, the returned code is equivalent to <var class="Arg">C</var> (see <code class="func">IsEquivalent</code> (<a href="chap4_mj.html#X843034687D9C75B0"><span class="RefLink">4.4-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := PuncturedCode( ReedMullerCode( 1, 4 ) );</span>
a linear [15,5,7]5 punctured code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := BCHCode( 15, 7, GF(2) );</span>
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 = C1;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">p := CodeIsomorphism( C1, C2 );</span>
( 2, 4,14, 9,13, 7,11,10, 6, 8,12, 5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3 := PermutedCode( C1, p );</span>
a linear [15,5,7]5 permuted code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 = C3;</span>
true 
</pre></div>

<p><a id="X87E5849784BC60D2" name="X87E5849784BC60D2"></a></p>

<h5>6.1-5 ExpurgatedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExpurgatedCode</code>( <var class="Arg">C</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">ExpurgatedCode</code> expurgates the code <var class="Arg">C</var>&gt; by throwing away codewords in list <var class="Arg">L</var>. <var class="Arg">C</var> must be a linear code. <var class="Arg">L</var> must be a list of codeword input. The generator matrix of the new code no longer is a basis for the codewords specified by <var class="Arg">L</var>. Since the returned code is still linear, it is very likely that, besides the words of <var class="Arg">L</var>, more codewords of <var class="Arg">C</var> are no longer in the new code.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := HammingCode( 4 );; WeightDistribution( C1 );</span>
[ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := Filtered( AsSSortedList(C1), i -&gt; WeightCodeword(i) = 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := ExpurgatedCode( C1, L );</span>
a linear [15,4,3..4]5..11 code, expurgated with 7 word(s)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightDistribution( C2 );</span>
[ 1, 0, 0, 0, 14, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] 
</pre></div>

<p>This function does not work on non-linear codes. For removing words from a non-linear code, use <code class="code">RemovedElementsCode</code> (see <code class="func">RemovedElementsCode</code> (<a href="chap6_mj.html#X7B0A6E1F82686B43"><span class="RefLink">6.1-7</span></a>)). For expurgating a code of all words of odd weight, use `EvenWeightSubcode' (see <code class="func">EvenWeightSubcode</code> (<a href="chap6_mj.html#X87691AB67FF5621B"><span class="RefLink">6.1-3</span></a>)).</p>

<p><a id="X8134BE2B8478BE8A" name="X8134BE2B8478BE8A"></a></p>

<h5>6.1-6 AugmentedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AugmentedCode</code>( <var class="Arg">C</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">AugmentedCode</code> returns <var class="Arg">C</var> after augmenting. <var class="Arg">C</var> must be a linear code, <var class="Arg">L</var> must be a list of codeword inputs. The generator matrix of the new code is a basis for the codewords specified by <var class="Arg">L</var> as well as the words that were already in code <var class="Arg">C</var>. Note that the new code in general will consist of more words than only the codewords of <var class="Arg">C</var> and the words <var class="Arg">L</var>. The returned code is also a linear code.</p>

<p>This command can also be called with the syntax <code class="code">AugmentedCode(C)</code>. When called without a list of codewords, <code class="code">AugmentedCode</code> returns <var class="Arg">C</var> after adding the all-ones vector to the generator matrix. <var class="Arg">C</var> must be a linear code. If the all-ones vector was already in the code, nothing happens and a copy of the argument is returned. If <var class="Arg">C</var> is a binary code which does not contain the all-ones vector, the complement of all codewords is added.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C31 := ReedMullerCode( 1, 3 );</span>
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C32 := AugmentedCode(C31,["00000011","00000101","00010001"]);</span>
a linear [8,7,1..2]1 code, augmented with 3 word(s)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C32 = ReedMullerCode( 2, 3 );</span>
true 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := CordaroWagnerCode(6);</span>
a linear [6,2,4]2..3 Cordaro-Wagner code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Codeword( [0,0,1,1,1,1] ) in C1;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := AugmentedCode( C1 );</span>
a linear [6,3,1..2]2..3 code, augmented with 1 word(s)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Codeword( [1,1,0,0,0,0] ) in C2;</span>
true
</pre></div>

<p>The function <code class="code">AddedElementsCode</code> adds elements to the codewords instead of adding them to the basis (see <code class="func">AddedElementsCode</code> (<a href="chap6_mj.html#X784E1255874FCA8A"><span class="RefLink">6.1-8</span></a>)).</p>

<p><a id="X7B0A6E1F82686B43" name="X7B0A6E1F82686B43"></a></p>

<h5>6.1-7 RemovedElementsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemovedElementsCode</code>( <var class="Arg">C</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">RemovedElementsCode</code> returns code <var class="Arg">C</var> after removing a list of codewords <var class="Arg">L</var> from its elements. <var class="Arg">L</var> must be a list of codeword input. The result is an unrestricted code.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := HammingCode( 4 );; WeightDistribution( C1 );</span>
[ 1, 0, 0, 35, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L := Filtered( AsSSortedList(C1), i -&gt; WeightCodeword(i) = 3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := RemovedElementsCode( C1, L );</span>
a (15,2013,3..15)2..15 code with 35 word(s) removed
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightDistribution( C2 );</span>
[ 1, 0, 0, 0, 105, 168, 280, 435, 435, 280, 168, 105, 35, 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimumDistance( C2 );</span>
3        # C2 is not linear, so the minimum weight does not have to
         # be equal to the minimum distance 
</pre></div>

<p>Adding elements to a code is done by the function <code class="code">AddedElementsCode</code> (see <code class="func">AddedElementsCode</code> (<a href="chap6_mj.html#X784E1255874FCA8A"><span class="RefLink">6.1-8</span></a>)). To remove codewords from the base of a linear code, use <code class="code">ExpurgatedCode</code> (see <code class="func">ExpurgatedCode</code> (<a href="chap6_mj.html#X87E5849784BC60D2"><span class="RefLink">6.1-5</span></a>)).</p>

<p><a id="X784E1255874FCA8A" name="X784E1255874FCA8A"></a></p>

<h5>6.1-8 AddedElementsCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddedElementsCode</code>( <var class="Arg">C</var>, <var class="Arg">L</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">AddedElementsCode</code> returns code <var class="Arg">C</var> after adding a list of codewords <var class="Arg">L</var> to its elements. <var class="Arg">L</var> must be a list of codeword input. The result is an unrestricted code.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := NullCode( 6, GF(2) );</span>
a cyclic [6,0,6]6 nullcode over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := AddedElementsCode( C1, [ "111111" ] );</span>
a (6,2,1..6)3 code with 1 word(s) added
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCyclicCode( C2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3 := AddedElementsCode( C2, [ "101010", "010101" ] );</span>
a (6,4,1..6)2 code with 2 word(s) added
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCyclicCode( C3 );</span>
true 
</pre></div>

<p>To remove elements from a code, use <code class="code">RemovedElementsCode</code> (see <code class="func">RemovedElementsCode</code> (<a href="chap6_mj.html#X7B0A6E1F82686B43"><span class="RefLink">6.1-7</span></a>)). To add elements to the base of a linear code, use <code class="code">AugmentedCode</code> (see <code class="func">AugmentedCode</code> (<a href="chap6_mj.html#X8134BE2B8478BE8A"><span class="RefLink">6.1-6</span></a>)).</p>

<p><a id="X81CBEAFF7B9DE6EF" name="X81CBEAFF7B9DE6EF"></a></p>

<h5>6.1-9 ShortenedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ShortenedCode</code>( <var class="Arg">C</var>[, <var class="Arg">L</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">ShortenedCode( C )</code> returns the code <var class="Arg">C</var> shortened by taking a cross section. If <var class="Arg">C</var> is a linear code, this is done by removing all codewords that start with a non-zero entry, after which the first column is cut off. If <var class="Arg">C</var> was a <span class="SimpleMath">\([n,k,d]\)</span> code, the shortened code generally is a <span class="SimpleMath">\([n-1,k-1,d]\)</span> code. It is possible that the dimension remains the same; it is also possible that the minimum distance increases.</p>

<p>If <var class="Arg">C</var> is a non-linear code, <code class="code">ShortenedCode</code> first checks which finite field element occurs most often in the first column of the codewords. The codewords not starting with this element are removed from the code, after which the first column is cut off. The resulting shortened code has at least the same minimum distance as <var class="Arg">C</var>.</p>

<p>This command can also be called using the syntax <code class="code">ShortenedCode(C,L)</code>. When called in this format, <code class="code">ShortenedCode</code> repeats the shortening process on each of the columns specified by <var class="Arg">L</var>. <var class="Arg">L</var> therefore is a list of integers. The column numbers in <var class="Arg">L</var> are the numbers as they are before the shortening process. If <var class="Arg">L</var> has <span class="SimpleMath">\(l\)</span> entries, the returned code has a word length of <span class="SimpleMath">\(l\)</span> positions shorter than <var class="Arg">C</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := HammingCode( 4 );</span>
a linear [15,11,3]1 Hamming (4,2) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := ShortenedCode( C1 );</span>
a linear [14,10,3]2 shortened code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3 := ElementsCode( ["1000", "1101", "0011" ], GF(2) );</span>
a (4,3,1..4)2 user defined unrestricted code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimumDistance( C3 );</span>
2
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C4 := ShortenedCode( C3 );</span>
a (3,2,2..3)1..2 shortened code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSSortedList( C4 );</span>
[ [ 0 0 0 ], [ 1 0 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C5 := HammingCode( 5, GF(2) );</span>
a linear [31,26,3]1 Hamming (5,2) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C6 := ShortenedCode( C5, [ 1, 2, 3 ] );</span>
a linear [28,23,3]2 shortened code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">OptimalityLinearCode( C6 );</span>
0
</pre></div>

<p>The function <code class="code">LengthenedCode</code> lengthens the code again (only for linear codes), see <code class="func">LengthenedCode</code> (<a href="chap6_mj.html#X7A5D5419846FC867"><span class="RefLink">6.1-10</span></a>). In general, this is not exactly the inverse function.</p>

<p><a id="X7A5D5419846FC867" name="X7A5D5419846FC867"></a></p>

<h5>6.1-10 LengthenedCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LengthenedCode</code>( <var class="Arg">C</var>[, <var class="Arg">i</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">LengthenedCode( C )</code> returns the code <var class="Arg">C</var> lengthened. <var class="Arg">C</var> must be a linear code. First, the all-ones vector is added to the generator matrix (see <code class="func">AugmentedCode</code> (<a href="chap6_mj.html#X8134BE2B8478BE8A"><span class="RefLink">6.1-6</span></a>)). If the all-ones vector was already a codeword, nothing happens to the code. Then, the code is extended <var class="Arg">i</var> times (see <code class="func">ExtendedCode</code> (<a href="chap6_mj.html#X794679BE7F9EB5C1"><span class="RefLink">6.1-1</span></a>)). <var class="Arg">i</var> is equal to <span class="SimpleMath">\(1\)</span> by default. If <var class="Arg">C</var> was an <span class="SimpleMath">\([n,k]\)</span> code, the new code generally is a <span class="SimpleMath">\([n+i,k+1]\)</span> code.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := CordaroWagnerCode( 5 );</span>
a linear [5,2,3]2 Cordaro-Wagner code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := LengthenedCode( C1 );</span>
a linear [6,3,2]2..3 code, lengthened with 1 column(s) 
</pre></div>

<p><code class="code">ShortenedCode</code>' shortens the code, see <code class="func">ShortenedCode</code> (<a href="chap6_mj.html#X81CBEAFF7B9DE6EF"><span class="RefLink">6.1-9</span></a>). In general, this is not exactly the inverse function.</p>

<p><a id="X7982D699803ECD0F" name="X7982D699803ECD0F"></a></p>

<h5>6.1-11 SubCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SubCode</code>( <var class="Arg">C</var>[, <var class="Arg">s</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function <code class="code">SubCode</code> returns a subcode of <var class="Arg">C</var> by taking the first <span class="SimpleMath">\(k - s\)</span> rows of the generator matrix of <var class="Arg">C</var>, where <span class="SimpleMath">\(k\)</span> is the dimension of <var class="Arg">C</var>. The interger <var class="Arg">s</var> may be omitted and in this case it is assumed as 1.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := BCHCode(31,11);</span>
a cyclic [31,11,11]7..11 BCH code, delta=11, b=1 over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S1:= SubCode(C);</span>
a linear [31,10,11]7..13 subcode
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightDistribution(S1);</span>
[ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 120, 190, 0, 0, 272, 255, 0, 0, 120, 66,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">S2:= SubCode(C, 8);</span>
a linear [31,3,11]14..20 subcode
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">History(S2);</span>
[ "a linear [31,3,11]14..20 subcode of",
  "a cyclic [31,11,11]7..11 BCH code, delta=11, b=1 over GF(2)" ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightDistribution(S2);</span>
[ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0 ]
</pre></div>

<p><a id="X809376187C1525AA" name="X809376187C1525AA"></a></p>

<h5>6.1-12 ResidueCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ResidueCode</code>( <var class="Arg">C</var>[, <var class="Arg">c</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The function <code class="code">ResidueCode</code> takes a codeword <var class="Arg">c</var> of <var class="Arg">C</var> (if <var class="Arg">c</var> is omitted, a codeword of minimal weight is used). It removes this word and all its linear combinations from the code and then punctures the code in the coordinates where <var class="Arg">c</var> is unequal to zero. The resulting code is an <span class="SimpleMath">\([n-w, k-1, d-\lfloor w*(q-1)/q \rfloor ]\)</span> code. <var class="Arg">C</var> must be a linear code and <var class="Arg">c</var> must be non-zero. If <var class="Arg">c</var> is not in <var class="Arg"></var> then no change is made to <var class="Arg">C</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := BCHCode( 15, 7 );</span>
a cyclic [15,5,7]5 BCH code, delta=7, b=1 over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := ResidueCode( C1 );</span>
a linear [8,4,4]2 residue code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := Codeword( [ 0,0,0,1,0,0,1,1,0,1,0,1,1,1,1 ], C1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3 := ResidueCode( C1, c );</span>
a linear [7,4,3]1 residue code 
</pre></div>

<p><a id="X7E92DC9581F96594" name="X7E92DC9581F96594"></a></p>

<h5>6.1-13 ConstructionBCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConstructionBCode</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The function <code class="code">ConstructionBCode</code> takes a binary linear code <var class="Arg">C</var> and calculates the minimum distance of the dual of <var class="Arg">C</var> (see <code class="func">DualCode</code> (<a href="chap6_mj.html#X799B12F085ACB609"><span class="RefLink">6.1-14</span></a>)). It then removes the columns of the parity check matrix of <var class="Arg">C</var> where a codeword of the dual code of minimal weight has coordinates unequal to zero. The resulting matrix is a parity check matrix for an <span class="SimpleMath">\([n-dd, k-dd+1, \geq d]\)</span> code, where <span class="SimpleMath">\(dd\)</span> is the minimum distance of the dual of <var class="Arg">C</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := ReedMullerCode( 2, 5 );</span>
a linear [32,16,8]6 Reed-Muller (2,5) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := ConstructionBCode( C1 );</span>
a linear [24,9,8]5..10 Construction B (8 coordinates)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BoundsMinimumDistance( 24, 9, GF(2) );</span>
rec( n := 24, k := 9, q := 2, references := rec(  ), 
  construction := [ [ Operation "UUVCode" ], 
      [ [ [ Operation "UUVCode" ], [ [ [ Operation "DualCode" ], 
                      [ [ [ Operation "RepetitionCode" ], [ 6, 2 ] ] ] ], 
                  [ [ Operation "CordaroWagnerCode" ], [ 6 ] ] ] ], 
          [ [ Operation "CordaroWagnerCode" ], [ 12 ] ] ] ], lowerBound := 8, 
  lowerBoundExplanation := [ "Lb(24,9)=8, u u+v construction of C1 and C2:", 
      "Lb(12,7)=4, u u+v construction of C1 and C2:", 
      "Lb(6,5)=2, dual of the repetition code", 
      "Lb(6,2)=4, Cordaro-Wagner code", "Lb(12,2)=8, Cordaro-Wagner code" ], 
  upperBound := 8, 
  upperBoundExplanation := [ "Ub(24,9)=8, otherwise construction B would 
                             contradict:", "Ub(18,4)=8, Griesmer bound" ] )
# so C2 is optimal
</pre></div>

<p><a id="X799B12F085ACB609" name="X799B12F085ACB609"></a></p>

<h5>6.1-14 DualCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DualCode</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">DualCode</code> returns the dual code of <var class="Arg">C</var>. The dual code consists of all codewords that are orthogonal to the codewords of <var class="Arg">C</var>. If <var class="Arg">C</var> is a linear code with generator matrix <span class="SimpleMath">\(G\)</span>, the dual code has parity check matrix <span class="SimpleMath">\(G\)</span> (or if <var class="Arg">C</var> has parity check matrix <span class="SimpleMath">\(H\)</span>, the dual code has generator matrix <span class="SimpleMath">\(H\)</span>). So if <var class="Arg">C</var> is a linear <span class="SimpleMath">\([n, k]\)</span> code, the dual code of <var class="Arg">C</var> is a linear <span class="SimpleMath">\([n, n-k]\)</span> code. If <var class="Arg">C</var> is a cyclic code with generator polynomial <span class="SimpleMath">\(g(x)\)</span>, the dual code has the reciprocal polynomial of <span class="SimpleMath">\(g(x)\)</span> as check polynomial.</p>

<p>The dual code is always a linear code, even if <var class="Arg">C</var> is non-linear.</p>

<p>If a code <var class="Arg">C</var> is equal to its dual code, it is called <em>self-dual</em>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := ReedMullerCode( 1, 3 );</span>
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RD := DualCode( R );</span>
a linear [8,4,4]2 Reed-Muller (1,3) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R = RD;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := WholeSpaceCode( 7, GF(4) );</span>
a cyclic [7,7,1]0 whole space code over GF(4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DualCode( N ) = NullCode( 7, GF(4) );</span>
true 
</pre></div>

<p><a id="X81FE1F387DFCCB22" name="X81FE1F387DFCCB22"></a></p>

<h5>6.1-15 ConversionFieldCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConversionFieldCode</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">ConversionFieldCode</code> returns the code obtained from <var class="Arg">C</var> after converting its field. If the field of <var class="Arg">C</var> is <span class="SimpleMath">\(GF(q^m)\)</span>, the returned code has field <span class="SimpleMath">\(GF(q)\)</span>. Each symbol of every codeword is replaced by a concatenation of <span class="SimpleMath">\(m\)</span> symbols from <span class="SimpleMath">\(GF(q)\)</span>. If <var class="Arg">C</var> is an <span class="SimpleMath">\((n, M, d_1)\)</span> code, the returned code is a <span class="SimpleMath">\((n\cdot m, M, d_2)\)</span> code, where <span class="SimpleMath">\(d_2 &gt; d_1\)</span>.</p>

<p>See also <code class="func">HorizontalConversionFieldMat</code> (<a href="chap7_mj.html#X8033E9A67BA155C8"><span class="RefLink">7.3-10</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := RepetitionCode( 4, GF(4) );</span>
a cyclic [4,1,4]3 repetition code over GF(4)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R2 := ConversionFieldCode( R );</span>
a linear [8,2,4]3..4 code, converted to basefield GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Size( R ) = Size( R2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorMat( R );</span>
[ [ Z(2)^0, Z(2)^0, Z(2)^0, Z(2)^0 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">GeneratorMat( R2 );</span>
[ [ Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2) ],
  [ 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0, 0*Z(2), Z(2)^0 ] ] 
</pre></div>

<p><a id="X82D18907800FE3D9" name="X82D18907800FE3D9"></a></p>

<h5>6.1-16 TraceCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; TraceCode</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Input: <var class="Arg">C</var> is a linear code defined over an extension <span class="SimpleMath">\(E\)</span> of <var class="Arg">F</var> (<var class="Arg">F</var> is the ``base field'')</p>

<p>Output: The linear code generated by <span class="SimpleMath">\(Tr_{E/F}(c)\)</span>, for all <span class="SimpleMath">\(c \in C\)</span>.</p>

<p><code class="code">TraceCode</code> returns the image of the code <var class="Arg">C</var> under the trace map. If the field of <var class="Arg">C</var> is <span class="SimpleMath">\(GF(q^m)\)</span>, the returned code has field <span class="SimpleMath">\(GF(q)\)</span>.</p>

<p>Very slow. It does not seem to be easy to related the parameters of the trace code to the original except in the ``Galois closed'' case.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C:=RandomLinearCode(10,4,GF(4)); MinimumDistance(C);</span>
a  [10,4,?] randomly generated code over GF(4)
5
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">trC:=TraceCode(C,GF(2)); MinimumDistance(trC);</span>
a linear [10,7,1]1..3 user defined unrestricted code over GF(2)
1

</pre></div>

<p><a id="X8799F4BF81B0842B" name="X8799F4BF81B0842B"></a></p>

<h5>6.1-17 CosetCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CosetCode</code>( <var class="Arg">C</var>, <var class="Arg">w</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">CosetCode</code> returns the coset of a code <var class="Arg">C</var> with respect to word <var class="Arg">w</var>. <var class="Arg">w</var> must be of the codeword type. Then, <var class="Arg">w</var> is added to each codeword of <var class="Arg">C</var>, yielding the elements of the new code. If <var class="Arg">C</var> is linear and <var class="Arg">w</var> is an element of <var class="Arg">C</var>, the new code is equal to <var class="Arg">C</var>, otherwise the new code is an unrestricted code.</p>

<p>Generating a coset is also possible by simply adding the word <var class="Arg">w</var> to <var class="Arg">C</var>. See <a href="chap4_mj.html#X832DA51986A3882C"><span class="RefLink">4.2</span></a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := HammingCode(3, GF(2));</span>
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := Codeword("1011011");; c in H;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CosetCode(H, c);</span>
a (7,16,3)1 coset code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List(AsSSortedList(C), el-&gt; Syndrome(H, el));</span>
[ [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
  [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ],
  [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ], [ 1 1 1 ] ]
# All elements of the coset have the same syndrome in H 
</pre></div>

<p><a id="X873EA5EE85699832" name="X873EA5EE85699832"></a></p>

<h5>6.1-18 ConstantWeightSubcode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConstantWeightSubcode</code>( <var class="Arg">C</var>, <var class="Arg">w</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">ConstantWeightSubcode</code> returns the subcode of <var class="Arg">C</var> that only has codewords of weight <var class="Arg">w</var>. The resulting code is a non-linear code, because it does not contain the all-zero vector.</p>

<p>This command also can be called with the syntax <code class="code">ConstantWeightSubcode(C)</code> In this format, <code class="code">ConstantWeightSubcode</code> returns the subcode of <var class="Arg">C</var> consisting of all minimum weight codewords of <var class="Arg">C</var>.</p>

<p><code class="code">ConstantWeightSubcode</code> first checks if Leon's binary <code class="code">wtdist</code> exists on your computer (in the default directory). If it does, then this program is called. Otherwise, the constant weight subcode is computed using a GAP program which checks each codeword in <var class="Arg">C</var> to see if it is of the desired weight.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">N := NordstromRobinsonCode();; WeightDistribution(N);</span>
[ 1, 0, 0, 0, 0, 0, 112, 0, 30, 0, 112, 0, 0, 0, 0, 0, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := ConstantWeightSubcode(N, 8);</span>
a (16,30,6..16)5..8 code with codewords of weight 8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightDistribution(C);</span>
[ 0, 0, 0, 0, 0, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0, 0, 0 ] 
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eg := ExtendedTernaryGolayCode();; WeightDistribution(eg);</span>
[ 1, 0, 0, 0, 0, 0, 264, 0, 0, 440, 0, 0, 24 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := ConstantWeightSubcode(eg);</span>
a (12,264,6..12)3..6 code with codewords of weight 6
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">WeightDistribution(C);</span>
[ 0, 0, 0, 0, 0, 0, 264, 0, 0, 0, 0, 0, 0 ] 
</pre></div>

<p><a id="X7AA203A380BC4C79" name="X7AA203A380BC4C79"></a></p>

<h5>6.1-19 StandardFormCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; StandardFormCode</code>( <var class="Arg">C</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">StandardFormCode</code> returns <var class="Arg">C</var> after putting it in standard form. If <var class="Arg">C</var> is a non-linear code, this means the elements are organized using lexicographical order. This means they form a legal GAP `Set'.</p>

<p>If <var class="Arg">C</var> is a linear code, the generator matrix and parity check matrix are put in standard form. The generator matrix then has an identity matrix in its left part, the parity check matrix has an identity matrix in its right part. Although <strong class="pkg">GUAVA</strong> always puts both matrices in a standard form using <code class="code">BaseMat</code>, this never alters the code. <code class="code">StandardFormCode</code> even applies column permutations if unavoidable, and thereby changes the code. The column permutations are recorded in the construction history of the new code (see <code class="func">Display</code> (<a href="chap4_mj.html#X83A5C59278E13248"><span class="RefLink">4.6-3</span></a>)). <var class="Arg">C</var> and the new code are of course equivalent.</p>

<p>If <var class="Arg">C</var> is a cyclic code, its generator matrix cannot be put in the usual upper triangular form, because then it would be inconsistent with the generator polynomial. The reason is that generating the elements from the generator matrix would result in a different order than generating the elements from the generator polynomial. This is an unwanted effect, and therefore <code class="code">StandardFormCode</code> just returns a copy of <var class="Arg">C</var> for cyclic codes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := GeneratorMatCode( Z(2) * [ [0,1,1,0], [0,1,0,1], [0,0,1,1] ], </span>
          "random form code", GF(2) );
a linear [4,2,1..2]1..2 random form code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Codeword( GeneratorMat( G ) );</span>
[ [ 0 1 0 1 ], [ 0 0 1 1 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Codeword( GeneratorMat( StandardFormCode( G ) ) );</span>
[ [ 1 0 0 1 ], [ 0 1 0 1 ] ] 
</pre></div>

<p><a id="X7EF49A257D6DB53B" name="X7EF49A257D6DB53B"></a></p>

<h5>6.1-20 PiecewiseConstantCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PiecewiseConstantCode</code>( <var class="Arg">part</var>, <var class="Arg">wts</var>[, <var class="Arg">F</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">PiecewiseConstantCode</code> returns a code with length <span class="SimpleMath">\(n = \sum n_i\)</span>, where <var class="Arg">part</var>=<span class="SimpleMath">\([ n_1, \dots, n_k ]\)</span>. <var class="Arg">wts</var> is a list of <var class="Arg">constraints</var> <span class="SimpleMath">\(w=(w_1,...,w_k)\)</span>, each of length <span class="SimpleMath">\(k\)</span>, where <span class="SimpleMath">\(0 \leq w_i \leq n_i\)</span>. The default field is <span class="SimpleMath">\(GF(2)\)</span>.</p>

<p>A constraint is a list of integers, and a word <span class="SimpleMath">\(c = ( c_1, \dots, c_k )\)</span> (according to <var class="Arg">part</var>, i.e., each <span class="SimpleMath">\(c_i\)</span> is a subword of length <span class="SimpleMath">\(n_i\)</span>) is in the resulting code if and only if, for some constraint <span class="SimpleMath">\(w \in\)</span> <var class="Arg">wts</var>, <span class="SimpleMath">\(\|c_i\| = w_i\)</span> for all <span class="SimpleMath">\(1 \leq i \leq k\)</span>, where <span class="SimpleMath">\(\| ...\|\)</span> denotes the Hamming weight.</p>

<p>An example might make things clearer:</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PiecewiseConstantCode( [ 2, 3 ],</span>
     [ [ 0, 0 ], [ 0, 3 ], [ 1, 0 ], [ 2, 2 ] ],GF(2) );
the C code programs are compiled, so using Leon's binary....
the C code programs are compiled, so using Leon's binary....
the C code programs are compiled, so using Leon's binary....
the C code programs are compiled, so using Leon's binary....
a (5,7,1..5)1..5 piecewise constant code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSSortedList(last);</span>
[ [ 0 0 0 0 0 ], [ 0 0 1 1 1 ], [ 0 1 0 0 0 ], [ 1 0 0 0 0 ], 
  [ 1 1 0 1 1 ], [ 1 1 1 0 1 ], [ 1 1 1 1 0 ] ]
</pre></div>

<p>The first constraint is satisfied by codeword 1, the second by codeword 2, the third by codewords 3 and 4, and the fourth by codewords 5, 6 and 7.</p>

<p><a id="X7964BF0081CC8352" name="X7964BF0081CC8352"></a></p>

<h4>6.2 <span class="Heading">
Functions that Generate a New Code from Two or More Given Codes
</span></h4>

<p><a id="X79E00D3A8367D65A" name="X79E00D3A8367D65A"></a></p>

<h5>6.2-1 DirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectSumCode</code>( <var class="Arg">C1</var>, <var class="Arg">C2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">DirectSumCode</code> returns the direct sum of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. The direct sum code consists of every codeword of <var class="Arg">C1</var> concatenated by every codeword of <var class="Arg">C2</var>. Therefore, if <var class="Arg">Ci</var> was a <span class="SimpleMath">\((n_i,M_i,d_i)\)</span> code, the result is a <span class="SimpleMath">\((n_1+n_2,M_1*M_2,min(d_1,d_2))\)</span> code.</p>

<p>If both <var class="Arg">C1</var> and <var class="Arg">C2</var> are linear codes, the result is also a linear code. If one of them is non-linear, the direct sum is non-linear too. In general, a direct sum code is not cyclic.</p>

<p>Performing a direct sum can also be done by adding two codes (see Section <a href="chap4_mj.html#X832DA51986A3882C"><span class="RefLink">4.2</span></a>). Another often used method is the `u, u+v'-construction, described in <code class="func">UUVCode</code> (<a href="chap6_mj.html#X86E9D6DE7F1A07E6"><span class="RefLink">6.2-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := ElementsCode( [ [1,0], [4,5] ], GF(7) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := ElementsCode( [ [0,0,0], [3,3,3] ], GF(7) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DirectSumCode(C1, C2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSSortedList(D);</span>
[ [ 1 0 0 0 0 ], [ 1 0 3 3 3 ], [ 4 5 0 0 0 ], [ 4 5 3 3 3 ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D = C1 + C2;   # addition = direct sum</span>
true 
</pre></div>

<p><a id="X86E9D6DE7F1A07E6" name="X86E9D6DE7F1A07E6"></a></p>

<h5>6.2-2 UUVCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UUVCode</code>( <var class="Arg">C1</var>, <var class="Arg">C2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">UUVCode</code> returns the so-called <span class="SimpleMath">\((u\|u+v)\)</span> construction applied to <var class="Arg">C1</var> and <var class="Arg">C2</var>. The resulting code consists of every codeword <span class="SimpleMath">\(u\)</span> of <var class="Arg">C1</var> concatenated by the sum of <span class="SimpleMath">\(u\)</span> and every codeword <span class="SimpleMath">\(v\)</span> of <var class="Arg">C2</var>. If <var class="Arg">C1</var> and <var class="Arg">C2</var> have different word lengths, sufficient zeros are added to the shorter code to make this sum possible. If <var class="Arg">Ci</var> is a <span class="SimpleMath">\((n_i,M_i,d_i)\)</span> code, the result is an <span class="SimpleMath">\((n_1+max(n_1,n_2),M_1\cdot M_2,min(2\cdot d_1,d_2))\)</span> code.</p>

<p>If both <var class="Arg">C1</var> and <var class="Arg">C2</var> are linear codes, the result is also a linear code. If one of them is non-linear, the UUV sum is non-linear too. In general, a UUV sum code is not cyclic.</p>

<p>The function <code class="code">DirectSumCode</code> returns another sum of codes (see <code class="func">DirectSumCode</code> (<a href="chap6_mj.html#X79E00D3A8367D65A"><span class="RefLink">6.2-1</span></a>)).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := EvenWeightSubcode(WholeSpaceCode(4, GF(2)));</span>
a cyclic [4,3,2]1 even weight subcode
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := RepetitionCode(4, GF(2));</span>
a cyclic [4,1,4]2 repetition code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R := UUVCode(C1, C2);</span>
a linear [8,4,4]2 U U+V construction code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">R = ReedMullerCode(1,3);</span>
true 
</pre></div>

<p><a id="X7BFBBA5784C293C1" name="X7BFBBA5784C293C1"></a></p>

<h5>6.2-3 DirectProductCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DirectProductCode</code>( <var class="Arg">C1</var>, <var class="Arg">C2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">DirectProductCode</code> returns the direct product of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. Both must be linear codes. Suppose <var class="Arg">Ci</var> has generator matrix <span class="SimpleMath">\(G_i\)</span>. The direct product of <var class="Arg">C1</var> and <var class="Arg">C2</var> then has the Kronecker product of <span class="SimpleMath">\(G_1\)</span> and <span class="SimpleMath">\(G_2\)</span> as the generator matrix (see the GAP command <code class="code">KroneckerProduct</code>).</p>

<p>If <var class="Arg">Ci</var> is a <span class="SimpleMath">\([n_i, k_i, d_i]\)</span> code, the direct product then is an <span class="SimpleMath">\([n_1\cdot n_2,k_1\cdot k_2,d_1\cdot d_2]\)</span> code.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L1 := LexiCode(10, 4, GF(2));</span>
a linear [10,5,4]2..4 lexicode over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">L2 := LexiCode(8, 3, GF(2));</span>
a linear [8,4,3]2..3 lexicode over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D := DirectProductCode(L1, L2);</span>
a linear [80,20,12]20..45 direct product code 
</pre></div>

<p><a id="X78F0B1BC81FB109C" name="X78F0B1BC81FB109C"></a></p>

<h5>6.2-4 IntersectionCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntersectionCode</code>( <var class="Arg">C1</var>, <var class="Arg">C2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">IntersectionCode</code> returns the intersection of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. This code consists of all codewords that are both in <var class="Arg">C1</var> and <var class="Arg">C2</var>. If both codes are linear, the result is also linear. If both are cyclic, the result is also cyclic.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := CyclicCodes(7, GF(2));</span>
[ a cyclic [7,7,1]0 enumerated code over GF(2),
  a cyclic [7,6,1..2]1 enumerated code over GF(2),
  a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
  a cyclic [7,0,7]7 enumerated code over GF(2),
  a cyclic [7,3,1..4]2..3 enumerated code over GF(2),
  a cyclic [7,4,1..3]1 enumerated code over GF(2),
  a cyclic [7,1,7]3 enumerated code over GF(2),
  a cyclic [7,4,1..3]1 enumerated code over GF(2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IntersectionCode(C[6], C[8]) = C[7];</span>
true 
</pre></div>

<p>The <em>hull</em> of a linear code is the intersection of the code with its dual code. In other words, the hull of <span class="SimpleMath">\(C\)</span> is <code class="code">IntersectionCode(C, DualCode(C))</code>.</p>

<p><a id="X8228A1F57A29B8F4" name="X8228A1F57A29B8F4"></a></p>

<h5>6.2-5 UnionCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; UnionCode</code>( <var class="Arg">C1</var>, <var class="Arg">C2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">UnionCode</code> returns the union of codes <var class="Arg">C1</var> and <var class="Arg">C2</var>. This code consists of the union of all codewords of <var class="Arg">C1</var> and <var class="Arg">C2</var> and all linear combinations. Therefore this function works only for linear codes. The function <code class="code">AddedElementsCode</code> can be used for non-linear codes, or if the resulting code should not include linear combinations. See <code class="func">AddedElementsCode</code> (<a href="chap6_mj.html#X784E1255874FCA8A"><span class="RefLink">6.1-8</span></a>). If both arguments are cyclic, the result is also cyclic.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := GeneratorMatCode([[1,0,1],[0,1,1]]*Z(2)^0, GF(2));</span>
a linear [3,2,1..2]1 code defined by generator matrix over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := GeneratorMatCode([[1,1,1]]*Z(2)^0, GF(2));</span>
a linear [3,1,3]1 code defined by generator matrix over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">U := UnionCode(G, H);</span>
a linear [3,3,1]0 union code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := Codeword("010");; c in G;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c in H;</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c in U;</span>
true 
</pre></div>

<p><a id="X7A85F8AF8154D387" name="X7A85F8AF8154D387"></a></p>

<h5>6.2-6 ExtendedDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExtendedDirectSumCode</code>( <var class="Arg">L</var>, <var class="Arg">B</var>, <var class="Arg">m</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>The extended direct sum construction is described in section V of Graham and Sloane <a href="chapBib_mj.html#biBGS85">[GS85]</a>. The resulting code consists of <var class="Arg">m</var> copies of <var class="Arg">L</var>, extended by repeating the codewords of <var class="Arg">B</var> <var class="Arg">m</var> times.</p>

<p>Suppose <var class="Arg">L</var> is an <span class="SimpleMath">\([n_L, k_L]r_L\)</span> code, and <var class="Arg">B</var> is an <span class="SimpleMath">\([n_L, k_B]r_B\)</span> code (non-linear codes are also permitted). The length of <var class="Arg">B</var> must be equal to the length of <var class="Arg">L</var>. The length of the new code is <span class="SimpleMath">\(n = m n_L\)</span>, the dimension (in the case of linear codes) is <span class="SimpleMath">\(k \leq m k_L + k_B\)</span>, and the covering radius is <span class="SimpleMath">\(r \leq \lfloor m \Psi( L, B ) \rfloor\)</span>, with</p>

<p class="center">\[
\Psi( L, B ) = \max_{u \in F_2^{n_L}} \frac{1}{2^{k_B}}
               \sum_{v \in B} {\rm d}( L, v + u ).
\]</p>

<p>However, this computation will not be executed, because it may be too time consuming for large codes.</p>

<p>If <span class="SimpleMath">\(L \subseteq B\)</span>, and <span class="SimpleMath">\(L\)</span> and <span class="SimpleMath">\(B\)</span> are linear codes, the last copy of <var class="Arg">L</var> is omitted. In this case the dimension is <span class="SimpleMath">\(k = m k_L + (k_B - k_L)\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := HammingCode( 3, GF(2) );</span>
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := WholeSpaceCode( 7, GF(2) );</span>
a cyclic [7,7,1]0 whole space code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := ExtendedDirectSumCode( c, d, 3 );</span>
a linear [21,15,1..3]2 3-fold extended direct sum code
</pre></div>

<p><a id="X7E17107686A845DB" name="X7E17107686A845DB"></a></p>

<h5>6.2-7 AmalgamatedDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmalgamatedDirectSumCode</code>( <var class="Arg">c1</var>, <var class="Arg">c2</var>[, <var class="Arg">check</var>] )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">AmalgamatedDirectSumCode</code> returns the amalgamated direct sum of the codes <var class="Arg">c1</var> and <var class="Arg">c2</var>. The amalgamated direct sum code consists of all codewords of the form <span class="SimpleMath">\((u \, \| \,0 \, \| \, v)\)</span> if <span class="SimpleMath">\((u \, \| \, 0) \in c_1\)</span> and <span class="SimpleMath">\((0 \, \| \, v) \in c_2\)</span> and all codewords of the form <span class="SimpleMath">\((u \, \| \, 1 \, \| \, v)\)</span> if <span class="SimpleMath">\((u \, \| \, 1) \in c_1\)</span> and <span class="SimpleMath">\((1 \, \| \, v) \in c_2\)</span>. The result is a code with length <span class="SimpleMath">\( n = n_1 + n_2 - 1 \)</span> and size <span class="SimpleMath">\( M \leq M_1 \cdot M_2 / 2 \)</span>.</p>

<p>If both codes are linear, they will first be standardized, with information symbols in the last and first coordinates of the first and second code, respectively.</p>

<p>If <var class="Arg">c1</var> is a normal code (see <code class="func">IsNormalCode</code> (<a href="chap7_mj.html#X80283A2F7C8101BD"><span class="RefLink">7.4-5</span></a>)) with the last coordinate acceptable (see <code class="func">IsCoordinateAcceptable</code> (<a href="chap7_mj.html#X7D24F8BF7F9A7BF1"><span class="RefLink">7.4-3</span></a>)), and <var class="Arg">c2</var> is a normal code with the first coordinate acceptable, then the covering radius of the new code is <span class="SimpleMath">\(r \leq r_1 + r_2 \)</span>. However, checking whether a code is normal or not is a lot of work, and almost all codes seem to be normal. Therefore, an option <var class="Arg">check</var> can be supplied. If <var class="Arg">check</var> is true, then the codes will be checked for normality. If <var class="Arg">check</var> is false or omitted, then the codes will not be checked. In this case it is assumed that they are normal. Acceptability of the last and first coordinate of the first and second code, respectively, is in the last case also assumed to be done by the user.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := HammingCode( 3, GF(2) );</span>
a linear [7,4,3]1 Hamming (3,2) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := ReedMullerCode( 1, 4 );</span>
a linear [16,5,8]6 Reed-Muller (1,4) code over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e := DirectSumCode( c, d );</span>
a linear [23,9,3]7 direct sum code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := AmalgamatedDirectSumCode( c, d );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimumDistance( f );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CoveringRadius( f );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f;</span>
a linear [22,8,3]7 amalgamated direct sum code
</pre></div>

<p><a id="X7D8981AF7DFE9814" name="X7D8981AF7DFE9814"></a></p>

<h5>6.2-8 BlockwiseDirectSumCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BlockwiseDirectSumCode</code>( <var class="Arg">C1</var>, <var class="Arg">L1</var>, <var class="Arg">C2</var>, <var class="Arg">L2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p><code class="code">BlockwiseDirectSumCode</code> returns a subcode of the direct sum of <var class="Arg">C1</var> and <var class="Arg">C2</var>. The fields of <var class="Arg">C1</var> and <var class="Arg">C2</var> must be same. The lists <var class="Arg">L1</var> and <var class="Arg">L2</var> are two equally long with elements from the ambient vector spaces of <var class="Arg">C1</var> and <var class="Arg">C2</var>, respectively, <em>or</em> <var class="Arg">L1</var> and <var class="Arg">L2</var> are two equally long lists containing codes. The union of the codes in <var class="Arg">L1</var> and <var class="Arg">L2</var> must be <var class="Arg">C1</var> and <var class="Arg">C2</var>, respectively.</p>

<p>In the first case, the blockwise direct sum code is defined as</p>

<p class="center">\[
bds = \bigcup_{1 \leq i \leq \ell} ( C_1 + (L_1)_i ) \oplus ( C_2 + (L_2)_i ),
\]</p>

<p>where <span class="SimpleMath">\(\ell\)</span> is the length of <var class="Arg">L1</var> and <var class="Arg">L2</var>, and <span class="SimpleMath">\(\oplus\)</span> is the direct sum.</p>

<p>In the second case, it is defined as</p>

<p class="center">\[
bds = \bigcup_{1 \leq i \leq \ell} ( (L_1)_i \oplus (L_2)_i ).
\]</p>

<p>The length of the new code is <span class="SimpleMath">\(n = n_1 + n_2\)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := HammingCode( 3, GF(2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := EvenWeightSubcode( WholeSpaceCode( 6, GF(2) ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BlockwiseDirectSumCode( C1, [[ 0,0,0,0,0,0,0 ],[ 1,0,1,0,1,0,0 ]],</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">C2, [[ 0,0,0,0,0,0 ],[ 1,0,1,0,1,0 ]] );</span>
a (13,1024,1..13)1..2 blockwise direct sum code
</pre></div>

<p><a id="X7C37D467791CE99B" name="X7C37D467791CE99B"></a></p>

<h5>6.2-9 ConstructionXCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConstructionXCode</code>( <var class="Arg">C</var>, <var class="Arg">A</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Consider a list of <span class="SimpleMath">\(j\)</span> linear codes of the same length <span class="SimpleMath">\(N\)</span> over the same field <span class="SimpleMath">\(F\)</span>, <span class="SimpleMath">\(C = \{ C_1, C_2, \ldots, C_j \}\)</span>, where the parameter of the <span class="SimpleMath">\(i\)</span>th code is <span class="SimpleMath">\(C_i = [N, K_i, D_i]\)</span> and <span class="SimpleMath">\(C_j \subset C_{j-1} \subset \ldots \subset C_2 \subset C_1\)</span>. Consider a list of <span class="SimpleMath">\(j-1\)</span> auxiliary linear codes of the same field <span class="SimpleMath">\(F\)</span>, <span class="SimpleMath">\(A = \{ A_1, A_2, \ldots, A_{j-1} \}\)</span> where the parameter of the <span class="SimpleMath">\(i\)</span>th code <span class="SimpleMath">\(A_i\)</span> is <span class="SimpleMath">\([n_i, k_i=(K_i-K_{i+1}), d_i]\)</span>, an <span class="SimpleMath">\([n, K_1, d]\)</span> linear code over field <span class="SimpleMath">\(F\)</span> can be constructed where <span class="SimpleMath">\(n = N + \sum_{i=1}^{j-1} n_i\)</span>, and <span class="SimpleMath">\(d = \min\{ D_j, D_{j-1} + d_{j-1}, D_{j-2} + d_{j-2} + d_{j-1}, \ldots, D_1 + \sum_{i=1}^{j-1} d_i\}\)</span>.</p>

<p>For more information on Construction X, refer to <a href="chapBib_mj.html#biBSloane72">[SRC72]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := BCHCode(127, 43);</span>
a cyclic [127,29,43]31..59 BCH code, delta=43, b=1 over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := BCHCode(127, 47);</span>
a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3 := BCHCode(127, 55);</span>
a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G1 := ShallowCopy( GeneratorMat(C2) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append(G1, [ GeneratorMat(C1)[23] ]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := GeneratorMatCode(G1, GF(2));</span>
a linear [127,23,1..43]35..63 code defined by generator matrix over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimumDistance(C1);</span>
43
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := [ C1, C2, C3 ];</span>
[ a linear [127,23,43]35..63 code defined by generator matrix over GF(2), 
  a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2), 
  a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset(C[1], C[2]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSubset(C[2], C[3]);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := [ RepetitionCode(4, GF(2)), EvenWeightSubcode( QRCode(17, GF(2)) ) ];</span>
[ a cyclic [4,1,4]2 repetition code over GF(2), a cyclic [17,8,6]3..6 even weight subcode ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CX := ConstructionXCode(C, A);</span>
a linear [148,23,53]43..74 Construction X code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">History(CX);</span>
[ "a linear [148,23,53]43..74 Construction X code of", 
  "Base codes: [ a cyclic [127,15,55]41..62 BCH code, delta=55, b=1 over GF(2)\
, a cyclic [127,22,47..51]36..63 BCH code, delta=47, b=1 over GF(2), a linear \
[127,23,43]35..63 code defined by generator matrix over GF(2) ]", 
  "Auxiliary codes: [ a cyclic [4,1,4]2 repetition code over GF(2), a cyclic [\
17,8,6]3..6 even weight subcode ]" ]
</pre></div>

<p><a id="X7B50943B8014134F" name="X7B50943B8014134F"></a></p>

<h5>6.2-10 ConstructionXXCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ConstructionXXCode</code>( <var class="Arg">C1</var>, <var class="Arg">C2</var>, <var class="Arg">C3</var>, <var class="Arg">A1</var>, <var class="Arg">A2</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Consider a set of linear codes over field <span class="SimpleMath">\(F\)</span> of the same length, <span class="SimpleMath">\(n\)</span>, <span class="SimpleMath">\(C_1=[n, k_1, d_1]\)</span>, <span class="SimpleMath">\(C_2=[n, k_2, d_2]\)</span> and <span class="SimpleMath">\(C_3=[n, k_3, d_3]\)</span> such that <span class="SimpleMath">\(C_2 \subset C_1\)</span>, <span class="SimpleMath">\(C_3 \subset C_1\)</span> and <span class="SimpleMath">\(C_4 = C_2 \cap C_3\)</span>. Given two auxiliary codes <span class="SimpleMath">\(A_1=[n_1, k_1-k_2, e_1]\)</span> and <span class="SimpleMath">\(A_2=[n_2, k_1-k_3, e_2]\)</span> over the same field <span class="SimpleMath">\(F\)</span>, there exists an <span class="SimpleMath">\([n+n_1+n_2, k_1, d]\)</span> linear code <span class="SimpleMath">\(C_{XX}\)</span> over field <span class="SimpleMath">\(F\)</span>, where <span class="SimpleMath">\(d = \min\{d_4, d_3 + e_1, d_2 + e_2, d_1 + e_1 + e_2\}\)</span>.</p>

<p>The codewords of <span class="SimpleMath">\(C_{XX}\)</span> can be partitioned into three sections <span class="SimpleMath">\(( v\;\|\;a\;\|\;b )\)</span> where <span class="SimpleMath">\(v\)</span> has length <span class="SimpleMath">\(n\)</span>, <span class="SimpleMath">\(a\)</span> has length <span class="SimpleMath">\(n_1\)</span> and <span class="SimpleMath">\(b\)</span> has length <span class="SimpleMath">\(n_2\)</span>. A codeword from Construction XX takes the following form:</p>


<ul>
<li><p><span class="SimpleMath">\(( v \; \| \; 0 \; \| \; 0 )\)</span> if <span class="SimpleMath">\(v \in C_4\)</span></p>

</li>
<li><p><span class="SimpleMath">\(( v \; \| \; a_1 \; \| \; 0 )\)</span> if <span class="SimpleMath">\(v \in C_3 \backslash C_4\)</span></p>

</li>
<li><p><span class="SimpleMath">\(( v \; \| \; 0 \; \| \; a_2 )\)</span> if <span class="SimpleMath">\(v \in C_2 \backslash C_4\)</span></p>

</li>
<li><p><span class="SimpleMath">\(( v \; \| \; a_1 \; \| \; a_2 )\)</span> otherwise</p>

</li>
</ul>
<p>For more information on Construction XX, refer to <a href="chapBib_mj.html#biBAlltop84">[All84]</a>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := PrimitiveRoot(GF(32));</span>
Z(2^5)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f0 := MinimalPolynomial( GF(2), a^0 );</span>
x_1+Z(2)^0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f1 := MinimalPolynomial( GF(2), a^1 );</span>
x_1^5+x_1^2+Z(2)^0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f5 := MinimalPolynomial( GF(2), a^5 );</span>
x_1^5+x_1^4+x_1^2+x_1+Z(2)^0
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C2 := CheckPolCode( f0 * f1, 31, GF(2) );; MinimumDistance(C2);; Display(C2);</span>
a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C3 := CheckPolCode( f0 * f5, 31, GF(2) );; MinimumDistance(C3);; Display(C3);</span>
a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C1 := UnionCode(C2, C3);; MinimumDistance(C1);; Display(C1);</span>
a linear [31,11,11]7..11 union code of
U: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
V: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A1 := BestKnownLinearCode( 10, 5, GF(2) );</span>
a linear [10,5,4]2..4 shortened code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A2 := DualCode( RepetitionCode(6, GF(2)) );</span>
a cyclic [6,5,2]1 dual code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CXX:= ConstructionXXCode(C1, C2, C3, A1, A2 );</span>
a linear [47,11,15..17]13..23 Construction XX code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimumDistance(CXX);</span>
17
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">History(CXX);        </span>
[ "a linear [47,11,17]13..23 Construction XX code of", 
  "C1: a cyclic [31,11,11]7..11 union code", 
  "C2: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)", 
  "C3: a cyclic [31,6,15]10..13 code defined by check polynomial over GF(2)", 
  "A1: a linear [10,5,4]2..4 shortened code", 
  "A2: a cyclic [6,5,2]1 dual code" ]
</pre></div>

<p><a id="X790C614985BFAE16" name="X790C614985BFAE16"></a></p>

<h5>6.2-11 BZCode</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BZCode</code>( <var class="Arg">O</var>, <var class="Arg">I</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>Given a set of outer codes of the same length <span class="SimpleMath">\(O_i = [N, K_i, D_i]\)</span> over GF(<span class="SimpleMath">\(q^{e_i}\)</span>), where <span class="SimpleMath">\(i=1,2,\ldots,t\)</span> and a set of inner codes of the same length <span class="SimpleMath">\(I_i = [n, k_i, d_i]\)</span> over GF(<span class="SimpleMath">\(q\)</span>), <code class="code">BZCode</code> returns a Blokh-Zyablov multilevel concatenated code with parameter <span class="SimpleMath">\([ n \times N, \sum_{i=1}^t e_i \times K_i, \min_{i=1,\ldots,t}\{d_i \times D_i\} ]\)</span> over GF(<span class="SimpleMath">\(q\)</span>).</p>

<p>Note that the set of inner codes must satisfy chain condition, i.e. <span class="SimpleMath">\(I_1 = [n, k_1, d_1] \subset I_2=[n, k_2, d_2] \subset \ldots \subset I_t=[n, k_t, d_t]\)</span> where <span class="SimpleMath">\(0=k_0 &lt; k_1 &lt; k_2 &lt; \ldots &lt; k_t\)</span>. The dimension of the inner codes must satisfy the condition <span class="SimpleMath">\(e_i = k_i - k_{i-1}\)</span>, where GF(<span class="SimpleMath">\(q^{e_i}\)</span>) is the field of the <span class="SimpleMath">\(i\)</span>th outer code.</p>

<p>For more information on Blokh-Zyablov multilevel concatenated code, refer to <a href="chapBib_mj.html#biBBrouwer98">[Bro98]</a>.</p>

<p><a id="X820327D6854A50B5" name="X820327D6854A50B5"></a></p>

<h5>6.2-12 BZCodeNC</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BZCodeNC</code>( <var class="Arg">O</var>, <var class="Arg">I</var> )</td><td class="tdright">(&nbsp;function&nbsp;)</td></tr></table></div>
<p>This function is the same as <code class="code">BZCode</code>, except this version is faster as it does not estimate the covering radius of the code. Users are encouraged to use this version unless you are working on very small codes.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Binary code</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O := [ CyclicMDSCode(2,3,7), BestKnownLinearCode(9,5,GF(2)), CyclicMDSCode(2,3,4) ];</span>
[ a cyclic [9,7,3]1 MDS code over GF(8), a linear [9,5,3]2..3 shortened code, 
  a cyclic [9,4,6]4..5 MDS code over GF(8) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A := ExtendedCode( HammingCode(3,GF(2)) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I := [ SubCode(A), A, DualCode( RepetitionCode(8, GF(2)) ) ];</span>
[ a linear [8,3,4]3..4 subcode, a linear [8,4,4]2 extended code, a cyclic [8,7,2]1 dual code ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C := BZCodeNC(O, I);</span>
a linear [72,38,12]0..72 Blokh Zyablov concatenated code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Non binary code</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">#</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O2 := ExtendedCode(GoppaCode(ConwayPolynomial(5,2), Elements(GF(5))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O3 := ExtendedCode(GoppaCode(ConwayPolynomial(5,3), Elements(GF(5))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O1 := DualCode( O3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimumDistance(O1);; MinimumDistance(O2);; MinimumDistance(O3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Cy := CyclicCodes(5, GF(5));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">for i in [4, 5] do; MinimumDistance(Cy[i]);; od;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">O  := [ O1, O2, O3 ];</span>
[ a linear [6,4,3]1 dual code, a linear [6,3,4]2..3 extended code,
  a linear [6,2,5]3..4 extended code ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">I  := [ Cy[5], Cy[4], Cy[3] ];</span>
[ a cyclic [5,1,5]3..4 enumerated code over GF(5),
  a cyclic [5,2,4]2..3 enumerated code over GF(5),
  a cyclic [5,3,1..3]2 enumerated code over GF(5) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">C  := BZCodeNC( O, I );</span>
a linear [30,9,5..15]0..30 Blokh Zyablov concatenated code
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MinimumDistance(C);</span>
15
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">History(C);</span>
[ "a linear [30,9,15]0..30 Blokh Zyablov concatenated code of",
  "Inner codes: [ a cyclic [5,1,5]3..4 enumerated code over GF(5), a cyclic [5\
,2,4]2..3 enumerated code over GF(5), a cyclic [5,3,1..3]2 enumerated code ove\
r GF(5) ]",
  "Outer codes: [ a linear [6,4,3]1 dual code, a linear [6,3,4]2..3 extended c\
ode, a linear [6,2,5]3..4 extended code ]" ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0_mj.html">[Top of Book]</a>&nbsp;  <a href="chap0_mj.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap5_mj.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap7_mj.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0_mj.html">Top</a>  <a href="chap1_mj.html">1</a>  <a href="chap2_mj.html">2</a>  <a href="chap3_mj.html">3</a>  <a href="chap4_mj.html">4</a>  <a href="chap5_mj.html">5</a>  <a href="chap6_mj.html">6</a>  <a href="chap7_mj.html">7</a>  <a href="chap8_mj.html">8</a>  <a href="chap9_mj.html">9</a>  <a href="chapBib_mj.html">Bib</a>  <a href="chapInd_mj.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
